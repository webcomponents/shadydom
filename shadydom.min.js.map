{"version":3,"sources":["utils.js","array-splice.js","tree.js","shady.js","innerHTML.js","element-mixin.js","patch.js","event-mixin.js","distributor.js","env.js"],"names":["isShadyRoot","obj","Boolean","__localName","matchesSelector","element","selector","matches","call","copyOwnProperty","name","source","target","let","pd","Object","getOwnPropertyDescriptor","defineProperty","extend","n","n$","getOwnPropertyNames","i","length","extendAll","sources","mixin","patchPrototype","proto","getPrototypeOf","hasOwnProperty","patchProto","create","__sourceProto","__patchProto","setPrototypeOf","newSplice","index","removed","addedCount","getNativeProperty","property","descriptors","HTMLElement","prototype","Element","Node","get","enqueue","callback","scheduled","utils.promish","then","flush","flushList","push","flushCount","shift","customElements","const","isFlushedMaxed","flushMax","Error","escapeReplace","c","escapeAttr","s","replace","escapeAttrRegExp","escapeData","escapeDataRegExp","makeSet","arr","set","getOuterHTML","node","parentNode","composed","nodeType","ELEMENT_NODE","attr","tagName","localName","attrs","attributes","value","voidElements","getInnerHTML","TEXT_NODE","data","plaintextParents","COMMENT_NODE","window","console","error","content","child","c$","childNodes","l","filterMutations","mutations","targetRootNode","getRootNode","filter","mutation","mutationInScope","addedNodes","nodes","Array","from","configurable","convertNodesIntoANode","document","item","createTextNode","parent","tree","Logical","getParentNode","mixinImpl","removeNodeFromParent","createDocumentFragment","appendChild","patchNode","utils.settings","inUse","isNodePatched","patchImpl","canPatchNode","saveChildNodes","patch","unpatchNode","unpatch","__patched","pathComposer","startNode","composedPath","current","startRoot","assignedSlot","DOCUMENT_FRAGMENT_NODE","host","retarget","refNode","path","utils.isShadyRoot","ancestor","lastRoot","root","rootIdx","refNodePath","p$","indexOf","mixinComposedFlag","Base","klazz","type","options","event","__composed","utils.mixin","fireHandlers","phase","hs","__handlers","fn","__immediatePropagationStopped","retargetNonBubblingEvent","e","__propagationStopped","Event","BUBBLING_PHASE","shouldCapture","optionsOrCapture","capture","addEventListener","this","__eventListenerCount","wrappedFn","__target","__relatedTarget","relatedTarget","utils.patchPrototype","EventMixin","eventPhase","stopImmediatePropagation","__eventWrapper","nonBubblingEventsToRetarget","bubble","origAddEventListener","removeEventListener","wrapper","origRemoveEventListener","idx","splice","activateFocusEventOverrides","ev","settings","ShadyDOM","hasNativeShadowDOM","attachShadow","force","promish","p","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","common","Promise","resolve","cb","twiddle","observer","MutationObserver","disconnect","observe","characterData","EDIT_LEAVE","EDIT_UPDATE","EDIT_ADD","EDIT_DELETE","ArraySplice","calcEditDistances","currentStart","currentEnd","old","oldStart","oldEnd","rowCount","columnCount","distances","j","equals","north","west","spliceOperationsFromEditDistances","edits","min","northWest","reverse","calcSplices","prefixCount","suffixCount","minLength","Math","sharedPrefix","sharedSuffix","ops","undefined","splices","oldIndex","searchLength","index1","index2","count","calculateSplices","previous","currentValue","previousValue","nativeInsertBefore","insertBefore","nativeAppendChild","nativeRemoveChild","removeChild","arrayCopyChildNodes","copy","firstChild","nextSibling","arrayCopyChildren","firstElementChild","nextElementSibling","arrayCopy","a$","Composed","hasParentNode","saveComposedData","__dom","hasChildNodes","getChildNodes","_getChildNodes","getFirstChild","getNextSibling","getLastChild","lastChild","getPreviousSibling","previousSibling","getFirstElementChild","_getFirstElementChild","getLastElementChild","_getLastElementChild","getNextElementSibling","_getNextElementSibling","getPreviousElementSibling","_getPreviousElementSibling","utils.common","recordInsertBefore","container","ref_node","_linkNode","recordRemoveChild","$parentNode","$childNodes","$firstChild","$nextSibling","getComposedChildNodes","$lastChild","$previousSibling","lastElementChild","previousElementSibling","clearChildNodes","saveParentNode","newChild","refChild","_addChild","currentParent","_removeChild","isFrag","oldParent","NormalizedEvent","inType","params","createEvent","initEvent","bubbles","cancelable","Distributor","anonymous","insertionPointTag","getInsertionPoints","querySelectorAll","hasInsertionPoint","_insertionPoints","isInsertionPoint","distribute","distributePool","collectPool","pool","dirtyRoots","distributeInsertionPoint","shadyRoot","_assignedSlot","insertionPoint","prevAssignedNodes","_assignedNodes","clearAssignedSlots","needsSlotChange","anyDistributed","matchesInsertionPoint","__prevAssignedSlot","distributeNodeInto","children","setDistributedNodesOnInsertionPoint","_fireSlotChange","slot","savePrevious","slotName","getAttribute","trim","_distributedNodes","d$","dispatchEvent","isFinalDestination","ShadyRoot","frag","__proto__","ShadyFragmentMixin","_init","ShadyMixin","_clean","_hasRendered","_distributor","update","distributionRoot","_findDistributionRoot","render","_elementNeedsDistribution","_skipUpdateInsertionPoints","updateInsertionPoints","compose","forceRender","i$","__insertionPoints","insertionPoints","_composeTree","_updateChildNodes","_composeNode","distributedNodes","distributedNode","d","next","getInsertionPointTag","DocumentFragment","utils.extend","list","addNode","ownerRoot","ownerShadyRootForNode","__noInsertionPoint","ipAdded","_maybeAddInsertionPoint","_addedNode","handled","_maybeDistribute","removeNode","distributed","logicalParent","maybeDistributeParent","_removeDistributedChildren","_removeOwnerShadyRoot","_removedNode","_scheduleObserver","addedNode","removedNode","removedNodes","schedule","_hasCachedOwnerRoot","__ownerShadyRoot","documentElement","contains","fragContent","querySelector","wrappedContent","hasContent","needsDist","_nodeNeedsDistribution","added","np","na","hostNeedsDist","ip$","_contains","dc$","assignedNodes","flatten","firstComposedNode","clearNode","maybeDistributeAttributeChange","query","matcher","halter","_queryElements","elements","_queryElement","result","activeElementForNode","active","activeElement","activeRoot","nativeCloneNode","cloneNode","nativeImportNode","Document","importNode","nativeSetAttribute","setAttribute","nativeRemoveAttribute","removeAttribute","NodeMixin","defineProperties","parentElement","ParentNodeMixin","append","ownerDocument","prepend","childElementCount","ChildNodeMixin","before","viablePreviousSibling","after","viableNextSibling","replaceWith","replaceChild","remove","FragmentMixin","utils.matchesSelector","deep","nc","externalNode","doc","isArray","textContent","tc","cn","join","text","innerHTML","createElement","ElementMixin","shadowRoot","activeElementDescriptor","ActiveElementMixin","UnderActiveElementMixin","_activeElement","Mixins","CharacterData","utils.extendAll","Fragment","AsyncObserver","_scheduled","callbacks","Set","this$1","takeRecords","forEach","observeChildren","add","_callback","_observer","_node","unobserveChildren","handle","delete","size","patchedCount","log","head","hasPrototypeDescriptors","warn","mixinForObject","mixinForNode","DOCUMENT_NODE","alwaysComposed","blur","focus","focusin","focusout","click","dblclick","mousedown","mouseenter","mouseleave","mousemove","mouseout","mouseover","mouseup","wheel","beforeinput","input","keydown","keyup","compositionstart","compositionupdate","compositionend","touchstart","touchend","touchmove","touchcancel","pointerover","pointerenter","pointerdown","pointermove","pointerup","pointercancel","pointerout","pointerleave","gotpointercapture","lostpointercapture","dragstart","drag","dragenter","dragleave","dragover","drop","dragend","DOMActivate","DOMFocusIn","DOMFocusOut","keypress","isTrusted","__composedPath","currentTarget","__relatedTargetComposedPath","stopPropagation","PatchedEvent","PatchedCustomEvent","CustomEvent","PatchedMouseEvent","MouseEvent","patch.patchNode","isPatched","patch.isNodePatched","patch.unpatchNode","createRootAndEnsurePatched","events.addEventListener","events.removeEventListener","events.PatchedEvent","events.PatchedCustomEvent","events.PatchedMouseEvent","events.activateFocusEventOverrides"],"mappings":"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","file":"shadydom.min.js","sourcesContent":["/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n'use strict';\r\n\r\nexport let settings = window.ShadyDOM || {};\r\n\r\nsettings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);\r\n\r\nsettings.inUse = settings.force || !settings.hasNativeShadowDOM;\r\n\r\nexport function isShadyRoot(obj) {\r\n  return Boolean(obj.__localName === 'ShadyRoot');\r\n}\r\n\r\nlet p = Element.prototype;\r\nlet matches = p.matches || p.matchesSelector ||\r\n  p.mozMatchesSelector || p.msMatchesSelector ||\r\n  p.oMatchesSelector || p.webkitMatchesSelector;\r\n\r\nexport function matchesSelector(element, selector) {\r\n  return matches.call(element, selector);\r\n}\r\n\r\nfunction copyOwnProperty(name, source, target) {\r\n  let pd = Object.getOwnPropertyDescriptor(source, name);\r\n  if (pd) {\r\n    Object.defineProperty(target, name, pd);\r\n  }\r\n}\r\n\r\nexport function extend(target, source) {\r\n  if (target && source) {\r\n    let n$ = Object.getOwnPropertyNames(source);\r\n    for (let i=0, n; (i<n$.length) && (n=n$[i]); i++) {\r\n      copyOwnProperty(n, source, target);\r\n    }\r\n  }\r\n  return target || source;\r\n}\r\n\r\nexport function extendAll(target, ...sources) {\r\n  for (let i=0; i < sources.length; i++) {\r\n    extend(target, sources[i]);\r\n  }\r\n  return target;\r\n}\r\n\r\nexport function mixin(target, source) {\r\n  for (var i in source) {\r\n    target[i] = source[i];\r\n  }\r\n  return target;\r\n}\r\n\r\nexport function patchPrototype(obj, mixin) {\r\n  let proto = Object.getPrototypeOf(obj);\r\n  if (!proto.hasOwnProperty('__patchProto')) {\r\n    let patchProto = Object.create(proto);\r\n    patchProto.__sourceProto = proto;\r\n    extend(patchProto, mixin);\r\n    proto.__patchProto = patchProto;\r\n  }\r\n  Object.setPrototypeOf(obj, proto.__patchProto);\r\n}\r\n\r\nexport function unpatchPrototype(obj) {\r\n  if (obj.__sourceProto) {\r\n    Object.setPrototypeOf(obj, obj.__sourceProto);\r\n  }\r\n}\r\n\r\nexport let common = {};\r\n\r\n// TODO(sorvell): actually rely on a real Promise polyfill...\r\nexport let promish;\r\nif (window.Promise) {\r\n  promish = Promise.resolve();\r\n} else {\r\n  promish = {\r\n    then: function(cb) {\r\n      let twiddle = document.createTextNode('');\r\n      let observer = new MutationObserver(function() {\r\n        observer.disconnect();\r\n        cb();\r\n      });\r\n      observer.observe(twiddle, {characterData: true});\r\n    }\r\n  }\r\n}","/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n'use strict';\r\n\r\nfunction newSplice(index, removed, addedCount) {\r\n  return {\r\n    index: index,\r\n    removed: removed,\r\n    addedCount: addedCount\r\n  };\r\n}\r\n\r\nconst EDIT_LEAVE = 0;\r\nconst EDIT_UPDATE = 1;\r\nconst EDIT_ADD = 2;\r\nconst EDIT_DELETE = 3;\r\n\r\nlet ArraySplice = {\r\n\r\n  // Note: This function is *based* on the computation of the Levenshtein\r\n  // \"edit\" distance. The one change is that \"updates\" are treated as two\r\n  // edits - not one. With Array splices, an update is really a delete\r\n  // followed by an add. By retaining this, we optimize for \"keeping\" the\r\n  // maximum array items in the original array. For example:\r\n  //\r\n  //   'xxxx123' -> '123yyyy'\r\n  //\r\n  // With 1-edit updates, the shortest path would be just to update all seven\r\n  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\r\n  // leaves the substring '123' intact.\r\n  calcEditDistances(current, currentStart, currentEnd,\r\n                              old, oldStart, oldEnd) {\r\n    // \"Deletion\" columns\r\n    let rowCount = oldEnd - oldStart + 1;\r\n    let columnCount = currentEnd - currentStart + 1;\r\n    let distances = new Array(rowCount);\r\n\r\n    // \"Addition\" rows. Initialize null column.\r\n    for (let i = 0; i < rowCount; i++) {\r\n      distances[i] = new Array(columnCount);\r\n      distances[i][0] = i;\r\n    }\r\n\r\n    // Initialize null row\r\n    for (let j = 0; j < columnCount; j++)\r\n      distances[0][j] = j;\r\n\r\n    for (let i = 1; i < rowCount; i++) {\r\n      for (let j = 1; j < columnCount; j++) {\r\n        if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))\r\n          distances[i][j] = distances[i - 1][j - 1];\r\n        else {\r\n          let north = distances[i - 1][j] + 1;\r\n          let west = distances[i][j - 1] + 1;\r\n          distances[i][j] = north < west ? north : west;\r\n        }\r\n      }\r\n    }\r\n\r\n    return distances;\r\n  },\r\n\r\n  // This starts at the final weight, and walks \"backward\" by finding\r\n  // the minimum previous weight recursively until the origin of the weight\r\n  // matrix.\r\n  spliceOperationsFromEditDistances(distances) {\r\n    let i = distances.length - 1;\r\n    let j = distances[0].length - 1;\r\n    let current = distances[i][j];\r\n    let edits = [];\r\n    while (i > 0 || j > 0) {\r\n      if (i == 0) {\r\n        edits.push(EDIT_ADD);\r\n        j--;\r\n        continue;\r\n      }\r\n      if (j == 0) {\r\n        edits.push(EDIT_DELETE);\r\n        i--;\r\n        continue;\r\n      }\r\n      let northWest = distances[i - 1][j - 1];\r\n      let west = distances[i - 1][j];\r\n      let north = distances[i][j - 1];\r\n\r\n      let min;\r\n      if (west < north)\r\n        min = west < northWest ? west : northWest;\r\n      else\r\n        min = north < northWest ? north : northWest;\r\n\r\n      if (min == northWest) {\r\n        if (northWest == current) {\r\n          edits.push(EDIT_LEAVE);\r\n        } else {\r\n          edits.push(EDIT_UPDATE);\r\n          current = northWest;\r\n        }\r\n        i--;\r\n        j--;\r\n      } else if (min == west) {\r\n        edits.push(EDIT_DELETE);\r\n        i--;\r\n        current = west;\r\n      } else {\r\n        edits.push(EDIT_ADD);\r\n        j--;\r\n        current = north;\r\n      }\r\n    }\r\n\r\n    edits.reverse();\r\n    return edits;\r\n  },\r\n\r\n  /**\r\n   * Splice Projection functions:\r\n   *\r\n   * A splice map is a representation of how a previous array of items\r\n   * was transformed into a new array of items. Conceptually it is a list of\r\n   * tuples of\r\n   *\r\n   *   <index, removed, addedCount>\r\n   *\r\n   * which are kept in ascending index order of. The tuple represents that at\r\n   * the |index|, |removed| sequence of items were removed, and counting forward\r\n   * from |index|, |addedCount| items were added.\r\n   */\r\n\r\n  /**\r\n   * Lacking individual splice mutation information, the minimal set of\r\n   * splices can be synthesized given the previous state and final state of an\r\n   * array. The basic approach is to calculate the edit distance matrix and\r\n   * choose the shortest path through it.\r\n   *\r\n   * Complexity: O(l * p)\r\n   *   l: The length of the current array\r\n   *   p: The length of the old array\r\n   */\r\n  calcSplices(current, currentStart, currentEnd,\r\n                        old, oldStart, oldEnd) {\r\n    let prefixCount = 0;\r\n    let suffixCount = 0;\r\n    let splice;\r\n\r\n    let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\r\n    if (currentStart == 0 && oldStart == 0)\r\n      prefixCount = this.sharedPrefix(current, old, minLength);\r\n\r\n    if (currentEnd == current.length && oldEnd == old.length)\r\n      suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\r\n\r\n    currentStart += prefixCount;\r\n    oldStart += prefixCount;\r\n    currentEnd -= suffixCount;\r\n    oldEnd -= suffixCount;\r\n\r\n    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\r\n      return [];\r\n\r\n    if (currentStart == currentEnd) {\r\n      splice = newSplice(currentStart, [], 0);\r\n      while (oldStart < oldEnd)\r\n        splice.removed.push(old[oldStart++]);\r\n\r\n      return [ splice ];\r\n    } else if (oldStart == oldEnd)\r\n      return [ newSplice(currentStart, [], currentEnd - currentStart) ];\r\n\r\n    let ops = this.spliceOperationsFromEditDistances(\r\n        this.calcEditDistances(current, currentStart, currentEnd,\r\n                               old, oldStart, oldEnd));\r\n\r\n    splice = undefined;\r\n    let splices = [];\r\n    let index = currentStart;\r\n    let oldIndex = oldStart;\r\n    for (let i = 0; i < ops.length; i++) {\r\n      switch(ops[i]) {\r\n        case EDIT_LEAVE:\r\n          if (splice) {\r\n            splices.push(splice);\r\n            splice = undefined;\r\n          }\r\n\r\n          index++;\r\n          oldIndex++;\r\n          break;\r\n        case EDIT_UPDATE:\r\n          if (!splice)\r\n            splice = newSplice(index, [], 0);\r\n\r\n          splice.addedCount++;\r\n          index++;\r\n\r\n          splice.removed.push(old[oldIndex]);\r\n          oldIndex++;\r\n          break;\r\n        case EDIT_ADD:\r\n          if (!splice)\r\n            splice = newSplice(index, [], 0);\r\n\r\n          splice.addedCount++;\r\n          index++;\r\n          break;\r\n        case EDIT_DELETE:\r\n          if (!splice)\r\n            splice = newSplice(index, [], 0);\r\n\r\n          splice.removed.push(old[oldIndex]);\r\n          oldIndex++;\r\n          break;\r\n      }\r\n    }\r\n\r\n    if (splice) {\r\n      splices.push(splice);\r\n    }\r\n    return splices;\r\n  },\r\n\r\n  sharedPrefix(current, old, searchLength) {\r\n    for (let i = 0; i < searchLength; i++)\r\n      if (!this.equals(current[i], old[i]))\r\n        return i;\r\n    return searchLength;\r\n  },\r\n\r\n  sharedSuffix(current, old, searchLength) {\r\n    let index1 = current.length;\r\n    let index2 = old.length;\r\n    let count = 0;\r\n    while (count < searchLength && this.equals(current[--index1], old[--index2]))\r\n      count++;\r\n\r\n    return count;\r\n  },\r\n\r\n  calculateSplices(current, previous) {\r\n    return this.calcSplices(current, 0, current.length, previous, 0,\r\n                            previous.length);\r\n  },\r\n\r\n  equals(currentValue, previousValue) {\r\n    return currentValue === previousValue;\r\n  }\r\n\r\n};\r\n\r\nexport let calculateSplices = (current, previous) =>\r\n  ArraySplice.calculateSplices(current, previous);\r\n","/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n'use strict';\r\n\r\n// TODO(sorvell): circular (patch loads tree and tree loads patch)\r\n// for now this is stuck on `utils`\r\n//import {patchNode} from './patch'\r\nimport * as utils from './utils'\r\n\r\n// native add/remove\r\nlet nativeInsertBefore = Element.prototype.insertBefore;\r\nlet nativeAppendChild = Element.prototype.appendChild;\r\nlet nativeRemoveChild = Element.prototype.removeChild;\r\n\r\n/**\r\n * `tree` is a dom manipulation library used by ShadyDom to\r\n * manipulate composed and logical trees.\r\n */\r\nexport let tree = {\r\n\r\n  // sad but faster than slice...\r\n  arrayCopyChildNodes(parent) {\r\n    let copy=[], i=0;\r\n    for (let n=parent.firstChild; n; n=n.nextSibling) {\r\n      copy[i++] = n;\r\n    }\r\n    return copy;\r\n  },\r\n\r\n  arrayCopyChildren(parent) {\r\n    let copy=[], i=0;\r\n    for (let n=parent.firstElementChild; n; n=n.nextElementSibling) {\r\n      copy[i++] = n;\r\n    }\r\n    return copy;\r\n  },\r\n\r\n  arrayCopy(a$) {\r\n    let l = a$.length;\r\n    let copy = new Array(l);\r\n    for (let i=0; i < l; i++) {\r\n      copy[i] = a$[i];\r\n    }\r\n    return copy;\r\n  },\r\n\r\n  saveChildNodes(node) {\r\n    tree.Logical.saveChildNodes(node);\r\n    if (!tree.Composed.hasParentNode(node)) {\r\n      tree.Composed.saveComposedData(node);\r\n      //tree.Composed.saveParentNode(node);\r\n    }\r\n    tree.Composed.saveChildNodes(node);\r\n  }\r\n\r\n};\r\n\r\ntree.Logical = {\r\n\r\n  hasParentNode(node) {\r\n    return Boolean(node.__dom && node.__dom.parentNode);\r\n  },\r\n\r\n  hasChildNodes(node) {\r\n    return Boolean(node.__dom && node.__dom.childNodes !== undefined);\r\n  },\r\n\r\n  getChildNodes(node) {\r\n    // note: we're distinguishing here between undefined and false-y:\r\n    // hasChildNodes uses undefined check to see if this element has logical\r\n    // children; the false-y check indicates whether or not we should rebuild\r\n    // the cached childNodes array.\r\n    return this.hasChildNodes(node) ? this._getChildNodes(node) :\r\n      tree.Composed.getChildNodes(node);\r\n  },\r\n\r\n  _getChildNodes(node) {\r\n    if (!node.__dom.childNodes) {\r\n      node.__dom.childNodes = [];\r\n      for (let n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\r\n        node.__dom.childNodes.push(n);\r\n      }\r\n    }\r\n    return node.__dom.childNodes;\r\n  },\r\n\r\n  // NOTE: __dom can be created under 2 conditions: (1) an element has a\r\n  // logical tree, or (2) an element is in a logical tree. In case (1), the\r\n  // element will store firstChild/lastChild, and in case (2), the element\r\n  // will store parentNode, nextSibling, previousSibling. This means that\r\n  // the mere existence of __dom is not enough to know if the requested\r\n  // logical data is available and instead we do an explicit undefined check.\r\n  getParentNode(node) {\r\n    return node.__dom && node.__dom.parentNode !== undefined ?\r\n      node.__dom.parentNode : tree.Composed.getParentNode(node);\r\n  },\r\n\r\n  getFirstChild(node) {\r\n    return node.__dom && node.__dom.firstChild !== undefined ?\r\n      node.__dom.firstChild : tree.Composed.getFirstChild(node);\r\n  },\r\n\r\n  getLastChild(node) {\r\n    return node.__dom && node.__dom.lastChild  !== undefined ?\r\n      node.__dom.lastChild : tree.Composed.getLastChild(node);\r\n  },\r\n\r\n  getNextSibling(node) {\r\n    return node.__dom && node.__dom.nextSibling  !== undefined ?\r\n      node.__dom.nextSibling : tree.Composed.getNextSibling(node);\r\n  },\r\n\r\n  getPreviousSibling(node) {\r\n    return node.__dom && node.__dom.previousSibling  !== undefined ?\r\n      node.__dom.previousSibling : tree.Composed.getPreviousSibling(node);\r\n  },\r\n\r\n  getFirstElementChild(node) {\r\n    return node.__dom && node.__dom.firstChild !== undefined ?\r\n      this._getFirstElementChild(node) :\r\n      tree.Composed.getFirstElementChild(node);\r\n  },\r\n\r\n  _getFirstElementChild(node) {\r\n    let n = node.__dom.firstChild;\r\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\r\n      n = n.__dom.nextSibling;\r\n    }\r\n    return n;\r\n  },\r\n\r\n  getLastElementChild(node) {\r\n    return node.__dom && node.__dom.lastChild !== undefined ?\r\n      this._getLastElementChild(node) :\r\n      tree.Composed.getLastElementChild(node);\r\n  },\r\n\r\n  _getLastElementChild(node) {\r\n    let n = node.__dom.lastChild;\r\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\r\n      n = n.__dom.previousSibling;\r\n    }\r\n    return n;\r\n  },\r\n\r\n  getNextElementSibling(node) {\r\n    return node.__dom && node.__dom.nextSibling !== undefined ?\r\n      this._getNextElementSibling(node) :\r\n      tree.Composed.getNextElementSibling(node);\r\n  },\r\n\r\n  _getNextElementSibling(node) {\r\n    let n = node.__dom.nextSibling;\r\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\r\n      n = this.getNextSibling(n);\r\n    }\r\n    return n;\r\n  },\r\n\r\n  getPreviousElementSibling(node) {\r\n    return node.__dom && node.__dom.previousSibling !== undefined ?\r\n      this._getPreviousElementSibling(node) :\r\n      tree.Composed.getPreviousElementSibling(node);\r\n  },\r\n\r\n  _getPreviousElementSibling(node) {\r\n    let n = node.__dom.previousSibling;\r\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\r\n      n = this.getPreviousSibling(n);\r\n    }\r\n    return n;\r\n  },\r\n\r\n  // Capture the list of light children. It's important to do this before we\r\n  // start transforming the DOM into \"rendered\" state.\r\n  // Children may be added to this list dynamically. It will be treated as the\r\n  // source of truth for the light children of the element. This element's\r\n  // actual children will be treated as the rendered state once this function\r\n  // has been called.\r\n  saveChildNodes(node) {\r\n    if (!this.hasChildNodes(node)) {\r\n      node.__dom = node.__dom || {};\r\n      node.__dom.firstChild = node.firstChild;\r\n      node.__dom.lastChild = node.lastChild;\r\n      let c$ = node.__dom.childNodes = tree.arrayCopyChildNodes(node);\r\n      for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {\r\n        n.__dom = n.__dom || {};\r\n        n.__dom.parentNode = node;\r\n        n.__dom.nextSibling = c$[i+1] || null;\r\n        n.__dom.previousSibling = c$[i-1] || null;\r\n        utils.common.patchNode(n);\r\n      }\r\n    }\r\n  },\r\n\r\n  // TODO(sorvell): may need to patch saveChildNodes iff the tree has\r\n  // already been distributed.\r\n  // NOTE: ensure `node` is patched...\r\n  recordInsertBefore(node, container, ref_node) {\r\n    container.__dom.childNodes = null;\r\n    // handle document fragments\r\n    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\r\n      let c$ = tree.arrayCopyChildNodes(node);\r\n      for (let i=0; i < c$.length; i++) {\r\n        this._linkNode(c$[i], container, ref_node);\r\n      }\r\n      // cleanup logical dom in doc fragment.\r\n      node.__dom = node.__dom || {};\r\n      node.__dom.firstChild = node.__dom.lastChild = null;\r\n      node.__dom.childNodes = null;\r\n    } else {\r\n      this._linkNode(node, container, ref_node);\r\n    }\r\n  },\r\n\r\n  _linkNode(node, container, ref_node) {\r\n    utils.common.patchNode(node);\r\n    ref_node = ref_node || null;\r\n    node.__dom = node.__dom || {};\r\n    container.__dom = container.__dom || {};\r\n    if (ref_node) {\r\n      ref_node.__dom = ref_node.__dom || {};\r\n    }\r\n    // update ref_node.previousSibling <-> node\r\n    node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling :\r\n      container.__dom.lastChild;\r\n    if (node.__dom.previousSibling) {\r\n      node.__dom.previousSibling.__dom.nextSibling = node;\r\n    }\r\n    // update node <-> ref_node\r\n    node.__dom.nextSibling = ref_node;\r\n    if (node.__dom.nextSibling) {\r\n      node.__dom.nextSibling.__dom.previousSibling = node;\r\n    }\r\n    // update node <-> container\r\n    node.__dom.parentNode = container;\r\n    if (ref_node) {\r\n      if (ref_node === container.__dom.firstChild) {\r\n        container.__dom.firstChild = node;\r\n      }\r\n    } else {\r\n      container.__dom.lastChild = node;\r\n      if (!container.__dom.firstChild) {\r\n        container.__dom.firstChild = node;\r\n      }\r\n    }\r\n    // remove caching of childNodes\r\n    container.__dom.childNodes = null;\r\n  },\r\n\r\n  recordRemoveChild(node, container) {\r\n    node.__dom = node.__dom || {};\r\n    container.__dom = container.__dom || {};\r\n    if (node === container.__dom.firstChild) {\r\n      container.__dom.firstChild = node.__dom.nextSibling;\r\n    }\r\n    if (node === container.__dom.lastChild) {\r\n      container.__dom.lastChild = node.__dom.previousSibling;\r\n    }\r\n    let p = node.__dom.previousSibling;\r\n    let n = node.__dom.nextSibling;\r\n    if (p) {\r\n      p.__dom = p.__dom || {};\r\n      p.__dom.nextSibling = n;\r\n    }\r\n    if (n) {\r\n      n.__dom = n.__dom || {};\r\n      n.__dom.previousSibling = p;\r\n    }\r\n    // When an element is removed, logical data is no longer tracked.\r\n    // Explicitly set `undefined` here to indicate this. This is disginguished\r\n    // from `null` which is set if info is null.\r\n    node.__dom.parentNode = node.__dom.previousSibling =\r\n      node.__dom.nextSibling = null;\r\n    // remove caching of childNodes\r\n    container.__dom.childNodes = null;\r\n  }\r\n\r\n}\r\n\r\n\r\n// TODO(sorvell): composed tree manipulation is made available\r\n// (1) to maninpulate the composed tree, and (2) to track changes\r\n// to the tree for optional patching pluggability.\r\ntree.Composed = {\r\n\r\n  hasParentNode(node) {\r\n    return Boolean(node.__dom && node.__dom.$parentNode !== undefined);\r\n  },\r\n\r\n  hasChildNodes(node) {\r\n    return Boolean(node.__dom && node.__dom.$childNodes !== undefined);\r\n  },\r\n\r\n  getChildNodes(node) {\r\n    return this.hasChildNodes(node) ? this._getChildNodes(node) :\r\n      (!node.__patched && tree.arrayCopy(node.childNodes));\r\n  },\r\n\r\n  _getChildNodes(node) {\r\n    if (!node.__dom.$childNodes) {\r\n      node.__dom.$childNodes = [];\r\n      for (let n=node.__dom.$firstChild; n; n=n.__dom.$nextSibling) {\r\n        node.__dom.$childNodes.push(n);\r\n      }\r\n    }\r\n    return node.__dom.$childNodes;\r\n  },\r\n\r\n  getComposedChildNodes(node) {\r\n    return node.__dom.$childNodes;\r\n  },\r\n\r\n  getParentNode(node) {\r\n    return this.hasParentNode(node) ? node.__dom.$parentNode :\r\n      (!node.__patched && node.parentNode);\r\n  },\r\n\r\n  getFirstChild(node) {\r\n    return node.__patched ? node.__dom.$firstChild : node.firstChild;\r\n  },\r\n\r\n  getLastChild(node) {\r\n    return node.__patched ? node.__dom.$lastChild : node.lastChild;\r\n  },\r\n\r\n  getNextSibling(node) {\r\n    return node.__patched ? node.__dom.$nextSibling : node.nextSibling;\r\n  },\r\n\r\n  getPreviousSibling(node) {\r\n    return node.__patched ? node.__dom.$previousSibling : node.previousSibling;\r\n  },\r\n\r\n  getFirstElementChild(node) {\r\n    return node.__patched ? this._getFirstElementChild(node) :\r\n      node.firstElementChild;\r\n  },\r\n\r\n  _getFirstElementChild(node) {\r\n    let n = node.__dom.$firstChild;\r\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\r\n      n = n.__dom.$nextSibling;\r\n    }\r\n    return n;\r\n  },\r\n\r\n  getLastElementChild(node) {\r\n    return node.__patched ? this._getLastElementChild(node) :\r\n      node.lastElementChild;\r\n  },\r\n\r\n  _getLastElementChild(node) {\r\n    let n = node.__dom.$lastChild;\r\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\r\n      n = n.__dom.$previousSibling;\r\n    }\r\n    return n;\r\n  },\r\n\r\n  getNextElementSibling(node) {\r\n    return node.__patched ? this._getNextElementSibling(node) :\r\n      node.nextElementSibling;\r\n  },\r\n\r\n  _getNextElementSibling(node) {\r\n    let n = node.__dom.$nextSibling;\r\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\r\n      n = this.getNextSibling(n);\r\n    }\r\n    return n;\r\n  },\r\n\r\n  getPreviousElementSibling(node) {\r\n    return node.__patched ? this._getPreviousElementSibling(node) :\r\n      node.previousElementSibling;\r\n  },\r\n\r\n  _getPreviousElementSibling(node) {\r\n    let n = node.__dom.$previousSibling;\r\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\r\n      n = this.getPreviousSibling(n);\r\n    }\r\n    return n;\r\n  },\r\n\r\n  saveChildNodes(node) {\r\n    if (!this.hasChildNodes(node)) {\r\n      node.__dom = node.__dom || {};\r\n      node.__dom.$firstChild = node.firstChild;\r\n      node.__dom.$lastChild = node.lastChild;\r\n      let c$ = node.__dom.$childNodes = tree.arrayCopyChildNodes(node);\r\n      for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {\r\n        this.saveComposedData(n);\r\n      }\r\n    }\r\n  },\r\n\r\n  saveComposedData(node) {\r\n    node.__dom = node.__dom || {};\r\n    if (node.__dom.$parentNode === undefined) {\r\n      node.__dom.$parentNode = node.parentNode;\r\n    }\r\n    if (node.__dom.$nextSibling === undefined) {\r\n      node.__dom.$nextSibling = node.nextSibling;\r\n    }\r\n    if (node.__dom.$previousSibling === undefined) {\r\n      node.__dom.$previousSibling = node.previousSibling;\r\n    }\r\n  },\r\n\r\n  recordInsertBefore(node, container, ref_node) {\r\n    container.__dom.$childNodes = null;\r\n    // handle document fragments\r\n    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\r\n      // TODO(sorvell): remember this for patching:\r\n      // the act of setting this info can affect patched nodes\r\n      // getters; therefore capture childNodes before patching.\r\n      for (let n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\r\n        this._linkNode(n, container, ref_node);\r\n      }\r\n    } else {\r\n      this._linkNode(node, container, ref_node);\r\n    }\r\n  },\r\n\r\n  _linkNode(node, container, ref_node) {\r\n    node.__dom = node.__dom || {};\r\n    container.__dom = container.__dom || {};\r\n    if (ref_node) {\r\n      ref_node.__dom = ref_node.__dom || {};\r\n    }\r\n    // update ref_node.previousSibling <-> node\r\n    node.__dom.$previousSibling = ref_node ? ref_node.__dom.$previousSibling :\r\n      container.__dom.$lastChild;\r\n    if (node.__dom.$previousSibling) {\r\n      node.__dom.$previousSibling.__dom.$nextSibling = node;\r\n    }\r\n    // update node <-> ref_node\r\n    node.__dom.$nextSibling = ref_node;\r\n    if (node.__dom.$nextSibling) {\r\n      node.__dom.$nextSibling.__dom.$previousSibling = node;\r\n    }\r\n    // update node <-> container\r\n    node.__dom.$parentNode = container;\r\n    if (ref_node) {\r\n      if (ref_node === container.__dom.$firstChild) {\r\n        container.__dom.$firstChild = node;\r\n      }\r\n    } else {\r\n      container.__dom.$lastChild = node;\r\n      if (!container.__dom.$firstChild) {\r\n        container.__dom.$firstChild = node;\r\n      }\r\n    }\r\n    // remove caching of childNodes\r\n    container.__dom.$childNodes = null;\r\n  },\r\n\r\n  recordRemoveChild(node, container) {\r\n    node.__dom = node.__dom || {};\r\n    container.__dom = container.__dom || {};\r\n    if (node === container.__dom.$firstChild) {\r\n      container.__dom.$firstChild = node.__dom.$nextSibling;\r\n    }\r\n    if (node === container.__dom.$lastChild) {\r\n      container.__dom.$lastChild = node.__dom.$previousSibling;\r\n    }\r\n    let p = node.__dom.$previousSibling;\r\n    let n = node.__dom.$nextSibling;\r\n    if (p) {\r\n      p.__dom = p.__dom || {};\r\n      p.__dom.$nextSibling = n;\r\n    }\r\n    if (n) {\r\n      n.__dom = n.__dom || {};\r\n      n.__dom.$previousSibling = p;\r\n    }\r\n    node.__dom.$parentNode = node.__dom.$previousSibling =\r\n      node.__dom.$nextSibling = null;\r\n    // remove caching of childNodes\r\n    container.__dom.$childNodes = null;\r\n  },\r\n\r\n  clearChildNodes(node) {\r\n    let c$ = this.getChildNodes(node);\r\n    for (let i=0, c; i < c$.length; i++) {\r\n      c = c$[i];\r\n      this.recordRemoveChild(c, node);\r\n      nativeRemoveChild.call(node, c)\r\n    }\r\n  },\r\n\r\n  saveParentNode(node) {\r\n    node.__dom = node.__dom || {};\r\n    node.__dom.$parentNode = node.parentNode;\r\n  },\r\n\r\n  insertBefore(parentNode, newChild, refChild) {\r\n    this.saveChildNodes(parentNode);\r\n    // remove from current location.\r\n    this._addChild(parentNode, newChild, refChild);\r\n    return nativeInsertBefore.call(parentNode, newChild, refChild || null);\r\n  },\r\n\r\n  appendChild(parentNode, newChild) {\r\n    this.saveChildNodes(parentNode);\r\n    this._addChild(parentNode, newChild);\r\n    return nativeAppendChild.call(parentNode, newChild);\r\n  },\r\n\r\n  removeChild(parentNode, node) {\r\n    let currentParent = this.getParentNode(node);\r\n    this.saveChildNodes(parentNode);\r\n    this._removeChild(parentNode, node);\r\n    if (currentParent === parentNode) {\r\n      return nativeRemoveChild.call(parentNode, node);\r\n    }\r\n  },\r\n\r\n  _addChild(parentNode, newChild, refChild) {\r\n    let isFrag = (newChild.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\r\n    let oldParent = this.getParentNode(newChild);\r\n    if (oldParent) {\r\n      this._removeChild(oldParent, newChild);\r\n    }\r\n    if (isFrag) {\r\n      let c$ = this.getChildNodes(newChild);\r\n      for (let i=0; i < c$.length; i++) {\r\n        let c = c$[i];\r\n        // unlink document fragment children\r\n        this._removeChild(newChild, c);\r\n        this.recordInsertBefore(c, parentNode, refChild);\r\n      }\r\n    } else {\r\n      this.recordInsertBefore(newChild, parentNode, refChild);\r\n    }\r\n  },\r\n\r\n  _removeChild(parentNode, node) {\r\n    this.recordRemoveChild(node, parentNode);\r\n  }\r\n\r\n};\r\n\r\n// for testing...\r\nlet descriptors = {};\r\nexport function getNativeProperty(element, property) {\r\n  if (!descriptors[property]) {\r\n    descriptors[property] = Object.getOwnPropertyDescriptor(\r\n      HTMLElement.prototype, property) ||\r\n    Object.getOwnPropertyDescriptor(\r\n      Element.prototype, property) ||\r\n    Object.getOwnPropertyDescriptor(\r\n      Node.prototype, property);\r\n  }\r\n  return descriptors[property].get.call(element);\r\n}\r\n\r\n// for testing...\r\nfunction assertNative(element, property, tracked) {\r\n  let native = getNativeProperty(element, property);\r\n  if (native != tracked && element.__patched) {\r\n    window.console.warn('tracked', tracked, 'native', native);\r\n  }\r\n  return tracked;\r\n}","/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n'use strict';\r\n\r\nimport {calculateSplices} from './array-splice'\r\nimport * as utils from './utils'\r\nimport {tree} from './tree'\r\nimport Distributor from './distributor'\r\n\r\n/**\r\n  Implements a pared down version of ShadowDOM's scoping, which is easy to\r\n  polyfill across browsers.\r\n*/\r\nexport class ShadyRoot {\r\n\r\n  constructor(host) {\r\n    if (!host) {\r\n      throw 'Must provide a host';\r\n    }\r\n    // NOTE: this strange construction is necessary because\r\n    // DocumentFragment cannot be subclassed on older browsers.\r\n    let frag = document.createDocumentFragment();\r\n    frag.__proto__ = ShadyFragmentMixin;\r\n    frag._init(host);\r\n    return frag;\r\n  }\r\n\r\n}\r\n\r\nlet ShadyMixin = {\r\n\r\n  _init(host) {\r\n    // NOTE: set a fake local name so this element can be\r\n    // distinguished from a DocumentFragment when patching.\r\n    // FF doesn't allow this to be `localName`\r\n    this.__localName = 'ShadyRoot';\r\n    // root <=> host\r\n    host.shadyRoot = this;\r\n    this.host = host;\r\n    // logical dom setup\r\n    tree.Logical.saveChildNodes(host);\r\n    tree.Logical.saveChildNodes(this);\r\n    // state flags\r\n    this._clean = true;\r\n    this._hasRendered = false;\r\n    this._distributor = new Distributor(this);\r\n    this.update();\r\n  },\r\n\r\n  // async render the \"top\" distributor (this is all that is needed to\r\n  // distribute this host).\r\n  update() {\r\n    // TODO(sorvell): instead the root should always be enqueued to helps record that it is dirty.\r\n    // Then, in `render`, the top most (in the distribution tree) \"dirty\" root should be rendered.\r\n    let distributionRoot = this._findDistributionRoot(this.host);\r\n    //console.log('update from', this.host, 'root', distributionRoot.host, distributionRoot._clean);\r\n    if (distributionRoot._clean) {\r\n      distributionRoot._clean = false;\r\n      enqueue(function() {\r\n        distributionRoot.render();\r\n      });\r\n    }\r\n  },\r\n\r\n  // TODO(sorvell): this may not return a shadowRoot (for example if the element is in a docFragment)\r\n  // this should only return a shadowRoot.\r\n  // returns the host that's the top of this host's distribution tree\r\n  _findDistributionRoot(element) {\r\n    let root = element.shadyRoot;\r\n    while (element && this._elementNeedsDistribution(element)) {\r\n      root = element.getRootNode();\r\n      element = root && root.host;\r\n    }\r\n    return root;\r\n  },\r\n\r\n  // Return true if a host's children includes\r\n  // an insertion point that selects selectively\r\n  _elementNeedsDistribution(element) {\r\n    let c$ = tree.Logical.getChildNodes(element);\r\n    for (let i=0, c; i < c$.length; i++) {\r\n      c = c$[i];\r\n      if (this._distributor.isInsertionPoint(c)) {\r\n        return element.getRootNode();\r\n      }\r\n    }\r\n  },\r\n\r\n  render() {\r\n    if (!this._clean) {\r\n      this._clean = true;\r\n      if (!this._skipUpdateInsertionPoints) {\r\n        this.updateInsertionPoints();\r\n      } else if (!this._hasRendered) {\r\n        this._insertionPoints = [];\r\n      }\r\n      this._skipUpdateInsertionPoints = false;\r\n      // TODO(sorvell): previous ShadyDom had a fast path here\r\n      // that would avoid distribution for initial render if\r\n      // no insertion points exist. We cannot currently do this because\r\n      // it relies on elements being in the physical shadowRoot element\r\n      // so that native methods will be used. The current append code\r\n      // simply provokes distribution in this case and does not put the\r\n      // nodes in the shadowRoot. This could be done but we'll need to\r\n      // consider if the special processing is worth the perf gain.\r\n      // if (!this._hasRendered && !this._insertionPoints.length) {\r\n      //   tree.Composed.clearChildNodes(this.host);\r\n      //   tree.Composed.appendChild(this.host, this);\r\n      // } else {\r\n      // logical\r\n      this.distribute();\r\n      // physical\r\n      this.compose();\r\n      this._hasRendered = true;\r\n    }\r\n  },\r\n\r\n  forceRender() {\r\n    this._clean = false;\r\n    this.render();\r\n  },\r\n\r\n  distribute() {\r\n    let dirtyRoots = this._distributor.distribute();\r\n    for (let i=0; i<dirtyRoots.length; i++) {\r\n      dirtyRoots[i].forceRender();\r\n    }\r\n  },\r\n\r\n  updateInsertionPoints() {\r\n    let i$ = this.__insertionPoints;\r\n    // if any insertion points have been removed, clear their distribution info\r\n    if (i$) {\r\n      for (let i=0, c; i < i$.length; i++) {\r\n        c = i$[i];\r\n        if (c.getRootNode() !== this) {\r\n          this._distributor.clearAssignedSlots(c);\r\n        }\r\n      }\r\n    }\r\n    i$ = this._insertionPoints = this._distributor.getInsertionPoints();\r\n    // ensure insertionPoints's and their parents have logical dom info.\r\n    // save logical tree info\r\n    // a. for shadyRoot\r\n    // b. for insertion points (fallback)\r\n    // c. for parents of insertion points\r\n    for (let i=0, c; i < i$.length; i++) {\r\n      c = i$[i];\r\n      tree.Logical.saveChildNodes(c);\r\n      tree.Logical.saveChildNodes(tree.Logical.getParentNode(c));\r\n    }\r\n  },\r\n\r\n  get _insertionPoints() {\r\n    if (!this.__insertionPoints) {\r\n      this.updateInsertionPoints();\r\n    }\r\n    return this.__insertionPoints || (this.__insertionPoints = []);\r\n  },\r\n\r\n  set _insertionPoints(insertionPoints) {\r\n    this.__insertionPoints = insertionPoints;\r\n  },\r\n\r\n  hasInsertionPoint() {\r\n    return this._distributor.hasInsertionPoint();\r\n  },\r\n\r\n  compose() {\r\n    // compose self\r\n    // note: it's important to mark this clean before distribution\r\n    // so that attachment that provokes additional distribution (e.g.\r\n    // adding something to your parentNode) works\r\n    this._composeTree();\r\n    // TODO(sorvell): See fast paths here in Polymer v1\r\n    // (these seem unnecessary)\r\n  },\r\n\r\n  // Reify dom such that it is at its correct rendering position\r\n  // based on logical distribution.\r\n  _composeTree() {\r\n    this._updateChildNodes(this.host, this._composeNode(this.host));\r\n    let p$ = this._insertionPoints || [];\r\n    for (let i=0, l=p$.length, p, parent; (i<l) && (p=p$[i]); i++) {\r\n      parent = tree.Logical.getParentNode(p);\r\n      if ((parent !== this.host) && (parent !== this)) {\r\n        this._updateChildNodes(parent, this._composeNode(parent));\r\n      }\r\n    }\r\n  },\r\n\r\n  // Returns the list of nodes which should be rendered inside `node`.\r\n  _composeNode(node) {\r\n    let children = [];\r\n    let c$ = tree.Logical.getChildNodes(node.shadyRoot || node);\r\n    for (let i = 0; i < c$.length; i++) {\r\n      let child = c$[i];\r\n      if (this._distributor.isInsertionPoint(child)) {\r\n        let distributedNodes = child._distributedNodes ||\r\n          (child._distributedNodes = []);\r\n        for (let j = 0; j < distributedNodes.length; j++) {\r\n          let distributedNode = distributedNodes[j];\r\n          if (this.isFinalDestination(child, distributedNode)) {\r\n            children.push(distributedNode);\r\n          }\r\n        }\r\n      } else {\r\n        children.push(child);\r\n      }\r\n    }\r\n    return children;\r\n  },\r\n\r\n  isFinalDestination(insertionPoint, node) {\r\n    return this._distributor.isFinalDestination(\r\n      insertionPoint, node);\r\n  },\r\n\r\n  // Ensures that the rendered node list inside `container` is `children`.\r\n  _updateChildNodes(container, children) {\r\n    let composed = tree.Composed.getChildNodes(container);\r\n    let splices = calculateSplices(children, composed);\r\n    // process removals\r\n    for (let i=0, d=0, s; (i<splices.length) && (s=splices[i]); i++) {\r\n      for (let j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {\r\n        // check if the node is still where we expect it is before trying\r\n        // to remove it; this can happen if we move a node and\r\n        // then schedule its previous host for distribution resulting in\r\n        // the node being removed here.\r\n        if (tree.Composed.getParentNode(n) === container) {\r\n          tree.Composed.removeChild(container, n);\r\n        }\r\n        composed.splice(s.index + d, 1);\r\n      }\r\n      d -= s.addedCount;\r\n    }\r\n    // process adds\r\n    for (let i=0, s, next; (i<splices.length) && (s=splices[i]); i++) { //eslint-disable-line no-redeclare\r\n      next = composed[s.index];\r\n      for (let j=s.index, n; j < s.index + s.addedCount; j++) {\r\n        n = children[j];\r\n        tree.Composed.insertBefore(container, n, next);\r\n        // TODO(sorvell): is this splice strictly needed?\r\n        composed.splice(j, 0, n);\r\n      }\r\n    }\r\n  },\r\n\r\n  getInsertionPointTag() {\r\n    return this._distributor.insertionPointTag;\r\n  }\r\n\r\n}\r\n\r\nlet ShadyFragmentMixin = Object.create(DocumentFragment.prototype);\r\nutils.extend(ShadyFragmentMixin, ShadyMixin);\r\n\r\n// let needsUpgrade = window.CustomElements && !CustomElements.useNative;\r\n\r\n// function upgradeLogicalChildren(children) {\r\n//   if (needsUpgrade && children) {\r\n//     for (let i=0; i < children.length; i++) {\r\n//       CustomElements.upgrade(children[i]);\r\n//     }\r\n//   }\r\n// }\r\n\r\n// render enqueuer/flusher\r\nlet customElements = window.customElements;\r\nlet flushList = [];\r\nlet scheduled;\r\nlet flushCount = 0;\r\nlet flushMax = 100;\r\nexport function enqueue(callback) {\r\n  if (!scheduled) {\r\n    scheduled = true;\r\n    utils.promish.then(flush);\r\n  }\r\n  flushList.push(callback);\r\n}\r\n\r\nexport function flush() {\r\n  scheduled = false;\r\n  flushCount++;\r\n  while (flushList.length) {\r\n    flushList.shift()();\r\n  }\r\n  if (customElements && customElements.flush) {\r\n    customElements.flush();\r\n  }\r\n  // continue flushing after elements are upgraded...\r\n  const isFlushedMaxed = (flushCount > flushMax);\r\n  if (flushList.length && !isFlushedMaxed) {\r\n      flush();\r\n  }\r\n  flushCount = 0;\r\n  if (isFlushedMaxed) {\r\n    throw new Error('Loop detected in ShadyDOM distribution, aborting.')\r\n  }\r\n}\r\n\r\nflush.list = flushList;","/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n'use strict';\r\n\r\n// Cribbed from ShadowDOM polyfill\r\n// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28\r\n/////////////////////////////////////////////////////////////////////////////\r\n// innerHTML and outerHTML\r\n\r\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\r\nlet escapeAttrRegExp = /[&\\u00A0\"]/g;\r\nlet escapeDataRegExp = /[&\\u00A0<>]/g;\r\n\r\nfunction escapeReplace(c) {\r\n  switch (c) {\r\n    case '&':\r\n      return '&amp;';\r\n    case '<':\r\n      return '&lt;';\r\n    case '>':\r\n      return '&gt;';\r\n    case '\"':\r\n      return '&quot;';\r\n    case '\\u00A0':\r\n      return '&nbsp;';\r\n  }\r\n}\r\n\r\nfunction escapeAttr(s) {\r\n  return s.replace(escapeAttrRegExp, escapeReplace);\r\n}\r\n\r\nfunction escapeData(s) {\r\n  return s.replace(escapeDataRegExp, escapeReplace);\r\n}\r\n\r\nfunction makeSet(arr) {\r\n  let set = {};\r\n  for (let i = 0; i < arr.length; i++) {\r\n    set[arr[i]] = true;\r\n  }\r\n  return set;\r\n}\r\n\r\n// http://www.whatwg.org/specs/web-apps/current-work/#void-elements\r\nlet voidElements = makeSet([\r\n  'area',\r\n  'base',\r\n  'br',\r\n  'col',\r\n  'command',\r\n  'embed',\r\n  'hr',\r\n  'img',\r\n  'input',\r\n  'keygen',\r\n  'link',\r\n  'meta',\r\n  'param',\r\n  'source',\r\n  'track',\r\n  'wbr'\r\n]);\r\n\r\nlet plaintextParents = makeSet([\r\n  'style',\r\n  'script',\r\n  'xmp',\r\n  'iframe',\r\n  'noembed',\r\n  'noframes',\r\n  'plaintext',\r\n  'noscript'\r\n]);\r\n\r\nexport function getOuterHTML(node, parentNode, composed) {\r\n  switch (node.nodeType) {\r\n    case Node.ELEMENT_NODE: {\r\n      let tagName = node.localName;\r\n      let s = '<' + tagName;\r\n      let attrs = node.attributes;\r\n      for (let i = 0, attr; (attr = attrs[i]); i++) {\r\n        s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\r\n      }\r\n      s += '>';\r\n      if (voidElements[tagName]) {\r\n        return s;\r\n      }\r\n      return s + getInnerHTML(node, composed) + '</' + tagName + '>';\r\n    }\r\n    case Node.TEXT_NODE: {\r\n      let data = node.data;\r\n      if (parentNode && plaintextParents[parentNode.localName]) {\r\n        return data;\r\n      }\r\n      return escapeData(data);\r\n    }\r\n    case Node.COMMENT_NODE: {\r\n      return '<!--' + node.data + '-->';\r\n    }\r\n    default: {\r\n      window.console.error(node);\r\n      throw new Error('not implemented');\r\n    }\r\n  }\r\n}\r\n\r\nexport function getInnerHTML(node, composed) {\r\n  if (node.localName === 'template') {\r\n    node = node.content;\r\n  }\r\n  let s = '';\r\n  let c$ = composed ? composed(node) : node.childNodes;\r\n  for (let i=0, l=c$.length, child; (i<l) && (child=c$[i]); i++) {\r\n    s += getOuterHTML(child, node, composed);\r\n  }\r\n  return s;\r\n}","/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n'use strict';\r\n\r\nimport * as utils from './utils'\r\nimport {getInnerHTML} from './innerHTML'\r\nimport {tree} from './tree'\r\n\r\nlet mixinImpl = {\r\n\r\n  // Try to add node. Record logical info, track insertion points, perform\r\n  // distribution iff needed. Return true if the add is handled.\r\n  addNode(container, node, ref_node) {\r\n    let ownerRoot = this.ownerShadyRootForNode(container);\r\n    if (ownerRoot) {\r\n      // optimization: special insertion point tracking\r\n      if (node.__noInsertionPoint) {\r\n        ownerRoot._skipUpdateInsertionPoints = true;\r\n      }\r\n      // note: we always need to see if an insertion point is added\r\n      // since this saves logical tree info; however, invalidation state\r\n      // needs\r\n      let ipAdded = this._maybeAddInsertionPoint(node, container, ownerRoot);\r\n      // invalidate insertion points IFF not already invalid!\r\n      if (ipAdded) {\r\n        ownerRoot._skipUpdateInsertionPoints = false;\r\n      }\r\n      this._addedNode(node, ownerRoot);\r\n    }\r\n    if (tree.Logical.hasChildNodes(container)) {\r\n      tree.Logical.recordInsertBefore(node, container, ref_node);\r\n    }\r\n    // if not distributing and not adding to host, do a fast path addition\r\n    let handled = this._maybeDistribute(node, container, ownerRoot) ||\r\n      container.shadyRoot;\r\n    return handled;\r\n  },\r\n\r\n  // Try to remove node: update logical info and perform distribution iff\r\n  // needed. Return true if the removal has been handled.\r\n  // note that it's possible for both the node's host and its parent\r\n  // to require distribution... both cases are handled here.\r\n  removeNode(node) {\r\n    // important that we want to do this only if the node has a logical parent\r\n    let logicalParent = tree.Logical.hasParentNode(node) &&\r\n      tree.Logical.getParentNode(node);\r\n    let distributed;\r\n    let ownerRoot = this.ownerShadyRootForNode(node);\r\n    if (logicalParent) {\r\n      // distribute node's parent iff needed\r\n      distributed = this.maybeDistributeParent(node);\r\n      tree.Logical.recordRemoveChild(node, logicalParent);\r\n      // remove node from root and distribute it iff needed\r\n      if (ownerRoot && (this._removeDistributedChildren(ownerRoot, node) ||\r\n        logicalParent.localName === ownerRoot.getInsertionPointTag())) {\r\n        ownerRoot._skipUpdateInsertionPoints = false;\r\n        ownerRoot.update();\r\n      }\r\n    }\r\n    this._removeOwnerShadyRoot(node);\r\n    if (ownerRoot) {\r\n      this._removedNode(node, ownerRoot);\r\n    }\r\n    return distributed;\r\n  },\r\n\r\n\r\n  _scheduleObserver(node, addedNode, removedNode) {\r\n    let observer = node.__dom && node.__dom.observer;\r\n    if (observer) {\r\n      if (addedNode) {\r\n        observer.addedNodes.push(addedNode);\r\n      }\r\n      if (removedNode) {\r\n        observer.removedNodes.push(removedNode);\r\n      }\r\n      observer.schedule();\r\n    }\r\n  },\r\n\r\n  removeNodeFromParent(node, parent) {\r\n    if (parent) {\r\n      this._scheduleObserver(parent, null, node);\r\n      this.removeNode(node);\r\n    } else {\r\n      this._removeOwnerShadyRoot(node);\r\n    }\r\n  },\r\n\r\n  _hasCachedOwnerRoot(node) {\r\n    return Boolean(node.__ownerShadyRoot !== undefined);\r\n  },\r\n\r\n  getRootNode(node) {\r\n    if (!node || !node.nodeType) {\r\n      return;\r\n    }\r\n    let root = node.__ownerShadyRoot;\r\n    if (root === undefined) {\r\n      if (utils.isShadyRoot(node)) {\r\n        root = node;\r\n      } else {\r\n        let parent = tree.Logical.getParentNode(node);\r\n        root = parent ? this.getRootNode(parent) : node;\r\n      }\r\n      // memo-ize result for performance but only memo-ize\r\n      // result if node is in the document. This avoids a problem where a root\r\n      // can be cached while an element is inside a fragment.\r\n      // If this happens and we cache the result, the value can become stale\r\n      // because for perf we avoid processing the subtree of added fragments.\r\n      if (document.documentElement.contains(node)) {\r\n        node.__ownerShadyRoot = root;\r\n      }\r\n    }\r\n    return root;\r\n  },\r\n\r\n  ownerShadyRootForNode(node) {\r\n    let root = this.getRootNode(node);\r\n    if (utils.isShadyRoot(root)) {\r\n      return root;\r\n    }\r\n  },\r\n\r\n  _maybeDistribute(node, container, ownerRoot) {\r\n    // TODO(sorvell): technically we should check non-fragment nodes for\r\n    // <content> children but since this case is assumed to be exceedingly\r\n    // rare, we avoid the cost and will address with some specific api\r\n    // when the need arises.  For now, the user must call\r\n    // distributeContent(true), which updates insertion points manually\r\n    // and forces distribution.\r\n    let insertionPointTag = ownerRoot && ownerRoot.getInsertionPointTag() || '';\r\n    let fragContent = (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) &&\r\n      !node.__noInsertionPoint &&\r\n      insertionPointTag && node.querySelector(insertionPointTag);\r\n    let wrappedContent = fragContent &&\r\n      (tree.Logical.getParentNode(fragContent).nodeType !==\r\n      Node.DOCUMENT_FRAGMENT_NODE);\r\n    let hasContent = fragContent || (node.localName === insertionPointTag);\r\n    // There are 3 possible cases where a distribution may need to occur:\r\n    // 1. <content> being inserted (the host of the shady root where\r\n    //    content is inserted needs distribution)\r\n    // 2. children being inserted into parent with a shady root (parent\r\n    //    needs distribution)\r\n    // 3. container is an insertionPoint\r\n    if (hasContent || (container.localName === insertionPointTag)) {\r\n      if (ownerRoot) {\r\n        // note, insertion point list update is handled after node\r\n        // mutations are complete\r\n        ownerRoot.update();\r\n      }\r\n    }\r\n    let needsDist = this._nodeNeedsDistribution(container);\r\n    if (needsDist) {\r\n      container.shadyRoot.update();\r\n    }\r\n    // Return true when distribution will fully handle the composition\r\n    // Note that if a content was being inserted that was wrapped by a node,\r\n    // and the parent does not need distribution, return false to allow\r\n    // the nodes to be added directly, after which children may be\r\n    // distributed and composed into the wrapping node(s)\r\n    return needsDist || (hasContent && !wrappedContent);\r\n  },\r\n\r\n  /* note: parent argument is required since node may have an out\r\n  of date parent at this point; returns true if a <content> is being added */\r\n  _maybeAddInsertionPoint(node, parent, root) {\r\n    let added;\r\n    let insertionPointTag = root.getInsertionPointTag();\r\n    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&\r\n      !node.__noInsertionPoint) {\r\n      let c$ = node.querySelectorAll(insertionPointTag);\r\n      for (let i=0, n, np, na; (i<c$.length) && (n=c$[i]); i++) {\r\n        np = tree.Logical.getParentNode(n);\r\n        // don't allow node's parent to be fragment itself\r\n        if (np === node) {\r\n          np = parent;\r\n        }\r\n        na = this._maybeAddInsertionPoint(n, np, root);\r\n        added = added || na;\r\n      }\r\n    } else if (node.localName === insertionPointTag) {\r\n      tree.Logical.saveChildNodes(parent);\r\n      tree.Logical.saveChildNodes(node);\r\n      added = true;\r\n    }\r\n    return added;\r\n  },\r\n\r\n  _nodeNeedsDistribution(node) {\r\n    return node && node.shadyRoot &&\r\n      node.shadyRoot.hasInsertionPoint();\r\n  },\r\n\r\n  // TODO(sorvell): needed for style scoping, use MO?\r\n  _addedNode() {},\r\n  _removedNode() {},\r\n  /*\r\n  _addedNode(node, root) {\r\n    // if (ShadyDOM.addedNode) {\r\n    //   ShadyDOM.addedNode(node, root);\r\n    // }\r\n  },\r\n\r\n  _removedNode(node, root) {\r\n    if (ShadyDOM.removedNode) {\r\n      ShadyDOM.removedNode(node, root);\r\n    }\r\n  },\r\n  */\r\n\r\n  _removeDistributedChildren(root, container) {\r\n    let hostNeedsDist;\r\n    let ip$ = root._insertionPoints;\r\n    for (let i=0; i<ip$.length; i++) {\r\n      let insertionPoint = ip$[i];\r\n      if (this._contains(container, insertionPoint)) {\r\n        let dc$ = insertionPoint.assignedNodes({flatten: true});\r\n        for (let j=0; j<dc$.length; j++) {\r\n          hostNeedsDist = true;\r\n          let node = dc$[j];\r\n          let parent = tree.Composed.getParentNode(node);\r\n          if (parent) {\r\n            tree.Composed.removeChild(parent, node);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return hostNeedsDist;\r\n  },\r\n\r\n  _contains(container, node) {\r\n    while (node) {\r\n      if (node == container) {\r\n        return true;\r\n      }\r\n      node = tree.Logical.getParentNode(node);\r\n    }\r\n  },\r\n\r\n  _removeOwnerShadyRoot(node) {\r\n    // optimization: only reset the tree if node is actually in a root\r\n    if (this._hasCachedOwnerRoot(node)) {\r\n      let c$ = tree.Logical.getChildNodes(node);\r\n      for (let i=0, l=c$.length, n; (i<l) && (n=c$[i]); i++) {\r\n        this._removeOwnerShadyRoot(n);\r\n      }\r\n    }\r\n    node.__ownerShadyRoot = undefined;\r\n  },\r\n\r\n  // TODO(sorvell): This will fail if distribution that affects this\r\n  // question is pending; this is expected to be exceedingly rare, but if\r\n  // the issue comes up, we can force a flush in this case.\r\n  firstComposedNode(insertionPoint) {\r\n    let n$ = insertionPoint.assignedNodes({flatten: true});\r\n    let root = this.getRootNode(insertionPoint);\r\n    for (let i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {\r\n      // means that we're composed to this spot.\r\n      if (root.isFinalDestination(insertionPoint, n)) {\r\n        return n;\r\n      }\r\n    }\r\n  },\r\n\r\n  clearNode(node) {\r\n    while (node.firstChild) {\r\n      node.removeChild(node.firstChild);\r\n    }\r\n  },\r\n\r\n  maybeDistributeParent(node) {\r\n    let parent = tree.Logical.getParentNode(node);\r\n    if (this._nodeNeedsDistribution(parent)) {\r\n      parent.shadyRoot.update();\r\n      return true;\r\n    }\r\n  },\r\n\r\n  maybeDistributeAttributeChange(node, name) {\r\n    let distribute = (node.localName === 'slot' && name === 'name');\r\n    if (distribute) {\r\n      let root = this.getRootNode(node);\r\n      if (root.update) {\r\n        root.update();\r\n      }\r\n    }\r\n  },\r\n\r\n  // NOTE: `query` is used primarily for ShadyDOM's querySelector impl,\r\n  // but it's also generally useful to recurse through the element tree\r\n  // and is used by Polymer's styling system.\r\n  query(node, matcher, halter) {\r\n    let list = [];\r\n    this._queryElements(tree.Logical.getChildNodes(node), matcher,\r\n      halter, list);\r\n    return list;\r\n  },\r\n\r\n  _queryElements(elements, matcher, halter, list) {\r\n    for (let i=0, l=elements.length, c; (i<l) && (c=elements[i]); i++) {\r\n      if (c.nodeType === Node.ELEMENT_NODE &&\r\n          this._queryElement(c, matcher, halter, list)) {\r\n        return true;\r\n      }\r\n    }\r\n  },\r\n\r\n  _queryElement(node, matcher, halter, list) {\r\n    let result = matcher(node);\r\n    if (result) {\r\n      list.push(node);\r\n    }\r\n    if (halter && halter(result)) {\r\n      return result;\r\n    }\r\n    this._queryElements(tree.Logical.getChildNodes(node), matcher,\r\n      halter, list);\r\n  },\r\n\r\n  activeElementForNode(node) {\r\n    let active = document.activeElement;\r\n    if (!active) {\r\n      return null;\r\n    }\r\n    let isShadyRoot = !!(utils.isShadyRoot(node));\r\n    if (node !== document) {\r\n      // If this node isn't a document or shady root, then it doesn't have\r\n      // an active element.\r\n      if (!isShadyRoot) {\r\n        return null;\r\n      }\r\n      // If this shady root's host is the active element or the active\r\n      // element is not a descendant of the host (in the composed tree),\r\n      // then it doesn't have an active element.\r\n      if (node.host === active ||\r\n          !node.host.contains(active)) {\r\n        return null;\r\n      }\r\n    }\r\n    // This node is either the document or a shady root of which the active\r\n    // element is a (composed) descendant of its host; iterate upwards to\r\n    // find the active element's most shallow host within it.\r\n    let activeRoot = this.ownerShadyRootForNode(active);\r\n    while (activeRoot && activeRoot !== node) {\r\n      active = activeRoot.host;\r\n      activeRoot = this.ownerShadyRootForNode(active);\r\n    }\r\n    if (node === document) {\r\n      // This node is the document, so activeRoot should be null.\r\n      return activeRoot ? null : active;\r\n    } else {\r\n      // This node is a non-document shady root, and it should be\r\n      // activeRoot.\r\n      return activeRoot === node ? active : null;\r\n    }\r\n  }\r\n\r\n};\r\n\r\nlet nativeCloneNode = Element.prototype.cloneNode;\r\nlet nativeImportNode = Document.prototype.importNode;\r\nlet nativeSetAttribute = Element.prototype.setAttribute;\r\nlet nativeRemoveAttribute = Element.prototype.removeAttribute;\r\n\r\nlet NodeMixin = {};\r\n\r\nObject.defineProperties(NodeMixin, {\r\n\r\n  parentElement: {\r\n    get() {\r\n      return tree.Logical.getParentNode(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  parentNode: {\r\n    get() {\r\n      return tree.Logical.getParentNode(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  nextSibling: {\r\n    get() {\r\n      return tree.Logical.getNextSibling(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  previousSibling: {\r\n    get() {\r\n      return tree.Logical.getPreviousSibling(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  nextElementSibling: {\r\n    get() {\r\n      return tree.Logical.getNextElementSibling(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  previousElementSibling: {\r\n    get() {\r\n      return tree.Logical.getPreviousElementSibling(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  assignedSlot: {\r\n    get() {\r\n      return this._assignedSlot;\r\n    },\r\n    configurable: true\r\n  }\r\n});\r\n\r\nlet ParentNodeMixin = {\r\n  \r\n  append(...nodes) {\r\n    const node = convertNodesIntoANode(nodes, this.ownerDocument);\r\n    return this.insertBefore(node);\r\n  },\r\n\r\n  prepend(...nodes) {\r\n    const node = convertNodesIntoANode(nodes, this.ownerDocument);\r\n    return this.insertBefore(node, this.firstChild);\r\n  }\r\n\r\n};\r\n\r\nObject.defineProperties(ParentNodeMixin, {\r\n\r\n  children: {\r\n    get() {\r\n      if (tree.Logical.hasChildNodes(this)) {\r\n        return Array.prototype.filter.call(this.childNodes, function(n) {\r\n          return (n.nodeType === Node.ELEMENT_NODE);\r\n        });\r\n      } else {\r\n        return tree.arrayCopyChildren(this);\r\n      }\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  firstElementChild: {\r\n    get() {\r\n      return tree.Logical.getFirstElementChild(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  lastElementChild: {\r\n    get() {\r\n      return tree.Logical.getLastElementChild(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  childElementCount: {\r\n    get() {\r\n      let count = 0;\r\n      const childNodes = tree.Logical.getChildNodes(this);\r\n      for (let i = 0; i < childNodes.length; i++) {\r\n        if (childNodes[i].nodeType === Node.ELEMENT_NODE) {\r\n          count++;\r\n        }\r\n      }\r\n      return count;\r\n    },\r\n    configurable: true\r\n  }\r\n\r\n});\r\n\r\nlet ChildNodeMixin = {\r\n\r\n  before(...nodes) {\r\n    // https://dom.spec.whatwg.org/#dom-childnode-before\r\n    const parent = this.parentNode;\r\n    if (!parent) {\r\n      return;\r\n    }\r\n    let viablePreviousSibling = this.previousSibling;\r\n    while (viablePreviousSibling && nodes.indexOf(viablePreviousSibling) !== -1) {\r\n      viablePreviousSibling = viablePreviousSibling.previousSibling;\r\n    }\r\n    const node = convertNodesIntoANode(nodes, parent.ownerDocument);\r\n    viablePreviousSibling = viablePreviousSibling ? viablePreviousSibling.nextSibling : parent.firstChild;\r\n    parent.insertBefore(node, viablePreviousSibling);\r\n  },\r\n\r\n  after(...nodes) {\r\n    // https://dom.spec.whatwg.org/#dom-childnode-after\r\n    const parent = this.parentNode;\r\n    if (!parent) {\r\n      return;\r\n    }\r\n    let viableNextSibling = this.nextSibling;\r\n    while (viableNextSibling && nodes.indexOf(viableNextSibling) !== -1) {\r\n      viableNextSibling = viableNextSibling.nextSibling;\r\n    }\r\n    const node = convertNodesIntoANode(nodes, parent.ownerDocument);\r\n    parent.insertBefore(node, viableNextSibling);\r\n  },\r\n\r\n  replaceWith(...nodes) {\r\n    // https://dom.spec.whatwg.org/#dom-childnode-replacewith\r\n    const parent = this.parentNode;\r\n    if (!parent) {\r\n      return;\r\n    }\r\n    let viableNextSibling = this.nextSibling;\r\n    while (viableNextSibling && nodes.indexOf(viableNextSibling) !== -1) {\r\n      viableNextSibling = viableNextSibling.nextSibling;\r\n    }\r\n    const node = convertNodesIntoANode(nodes, parent.ownerDocument);\r\n    if (this.parentNode === parent) {\r\n      parent.replaceChild(node, this);\r\n    }\r\n    else {\r\n      parent.insertBefore(node, viableNextSibling);\r\n    }\r\n  },\r\n\r\n  remove() {\r\n    // https://dom.spec.whatwg.org/#dom-childnode-remove\r\n    const parent = this.parentNode;\r\n    if (!parent) {\r\n      return;\r\n    }\r\n    parent.removeChild(this);\r\n  }\r\n\r\n};\r\n\r\nlet FragmentMixin = {\r\n\r\n  appendChild(node) {\r\n    return this.insertBefore(node);\r\n  },\r\n\r\n  // cases in which we may not be able to just do standard native call\r\n  // 1. container has a shadyRoot (needsDistribution IFF the shadyRoot\r\n  // has an insertion point)\r\n  // 2. container is a shadyRoot (don't distribute, instead set\r\n  // container to container.host.\r\n  // 3. node is <content> (host of container needs distribution)\r\n  insertBefore(node, ref_node) {\r\n    if (ref_node && tree.Logical.getParentNode(ref_node) !== this) {\r\n      throw Error('The ref_node to be inserted before is not a child ' +\r\n        'of this node');\r\n    }\r\n    // remove node from its current position iff it's in a tree.\r\n    if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\r\n      let parent = tree.Logical.getParentNode(node);\r\n      mixinImpl.removeNodeFromParent(node, parent);\r\n    }\r\n    if (!mixinImpl.addNode(this, node, ref_node)) {\r\n      if (ref_node) {\r\n        // if ref_node is an insertion point replace with first distributed node\r\n        let root = mixinImpl.ownerShadyRootForNode(ref_node);\r\n        if (root) {\r\n          ref_node = ref_node.localName === root.getInsertionPointTag() ?\r\n            mixinImpl.firstComposedNode(ref_node) : ref_node;\r\n        }\r\n      }\r\n      // if adding to a shadyRoot, add to host instead\r\n      let container = utils.isShadyRoot(this) ?\r\n        this.host : this;\r\n      if (ref_node) {\r\n        tree.Composed.insertBefore(container, node, ref_node);\r\n      } else {\r\n        tree.Composed.appendChild(container, node);\r\n      }\r\n    }\r\n    mixinImpl._scheduleObserver(this, node);\r\n    return node;\r\n  },\r\n\r\n  /**\r\n    Removes the given `node` from the element's `lightChildren`.\r\n    This method also performs dom composition.\r\n  */\r\n  removeChild(node) {\r\n    if (tree.Logical.getParentNode(node) !== this) {\r\n      throw Error('The node to be removed is not a child of this node: ' +\r\n        node);\r\n    }\r\n    if (!mixinImpl.removeNode(node)) {\r\n      // if removing from a shadyRoot, remove form host instead\r\n      let container = utils.isShadyRoot(this) ?\r\n        this.host :\r\n        this;\r\n      // not guaranteed to physically be in container; e.g.\r\n      // undistributed nodes.\r\n      let parent = tree.Composed.getParentNode(node);\r\n      if (container === parent) {\r\n        tree.Composed.removeChild(container, node);\r\n      }\r\n    }\r\n    mixinImpl._scheduleObserver(this, null, node);\r\n    return node;\r\n  },\r\n\r\n  replaceChild(node, ref_node) {\r\n    this.insertBefore(node, ref_node);\r\n    this.removeChild(ref_node);\r\n    return node;\r\n  },\r\n\r\n  // TODO(sorvell): consider doing native QSA and filtering results.\r\n  querySelector(selector) {\r\n    // match selector and halt on first result.\r\n    let result = mixinImpl.query(this, function(n) {\r\n      return utils.matchesSelector(n, selector);\r\n    }, function(n) {\r\n      return Boolean(n);\r\n    })[0];\r\n    return result || null;\r\n  },\r\n\r\n  querySelectorAll(selector) {\r\n    return mixinImpl.query(this, function(n) {\r\n      return utils.matchesSelector(n, selector);\r\n    });\r\n  },\r\n\r\n  cloneNode(deep) {\r\n    if (this.localName == 'template') {\r\n      return nativeCloneNode.call(this, deep);\r\n    } else {\r\n      let n = nativeCloneNode.call(this, false);\r\n      if (deep) {\r\n        let c$ = this.childNodes;\r\n        for (let i=0, nc; i < c$.length; i++) {\r\n          nc = c$[i].cloneNode(true);\r\n          n.appendChild(nc);\r\n        }\r\n      }\r\n      return n;\r\n    }\r\n  },\r\n\r\n  importNode(externalNode, deep) {\r\n    // for convenience use this node's ownerDoc if the node isn't a document\r\n    let doc = this instanceof Document ? this :\r\n      this.ownerDocument;\r\n    let n = nativeImportNode.call(doc, externalNode, false);\r\n    if (deep) {\r\n      let c$ = tree.Logical.getChildNodes(externalNode);\r\n      utils.common.patchNode(n);\r\n      for (let i=0, nc; i < c$.length; i++) {\r\n        nc = doc.importNode(c$[i], true);\r\n        n.appendChild(nc);\r\n      }\r\n    }\r\n    return n;\r\n  }\r\n};\r\n\r\nObject.defineProperties(FragmentMixin, {\r\n\r\n  childNodes: {\r\n    get() {\r\n      let c$ = tree.Logical.getChildNodes(this);\r\n      return Array.isArray(c$) ? c$ : tree.arrayCopyChildNodes(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  firstChild: {\r\n    get() {\r\n      return tree.Logical.getFirstChild(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  lastChild: {\r\n    get() {\r\n      return tree.Logical.getLastChild(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  // TODO(srovell): strictly speaking fragments do not have textContent\r\n  // or innerHTML but ShadowRoots do and are not easily distinguishable.\r\n  // textContent / innerHTML\r\n  textContent: {\r\n    get() {\r\n      if (this.childNodes) {\r\n        let tc = [];\r\n        for (let i = 0, cn = this.childNodes, c; (c = cn[i]); i++) {\r\n          if (c.nodeType !== Node.COMMENT_NODE) {\r\n            tc.push(c.textContent);\r\n          }\r\n        }\r\n        return tc.join('');\r\n      }\r\n      return '';\r\n    },\r\n    set(text) {\r\n      mixinImpl.clearNode(this);\r\n      if (text) {\r\n        this.appendChild(document.createTextNode(text));\r\n      }\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  innerHTML: {\r\n    get() {\r\n      return getInnerHTML(this);\r\n    },\r\n    set(text) {\r\n      mixinImpl.clearNode(this);\r\n      let d = document.createElement('div');\r\n      d.innerHTML = text;\r\n      // here, appendChild may move nodes async so we cannot rely\r\n      // on node position when copying\r\n      let c$ = tree.arrayCopyChildNodes(d);\r\n      for (let i=0; i < c$.length; i++) {\r\n        this.appendChild(c$[i]);\r\n      }\r\n    },\r\n    configurable: true\r\n  }\r\n\r\n});\r\n\r\nlet ElementMixin = {\r\n\r\n  // TODO(sorvell): should only exist on <slot>\r\n  assignedNodes(options) {\r\n    return (options && options.flatten ? this._distributedNodes :\r\n      this._assignedNodes) || [];\r\n  },\r\n\r\n\r\n  setAttribute(name, value) {\r\n    nativeSetAttribute.call(this, name, value);\r\n    if (!mixinImpl.maybeDistributeParent(this)) {\r\n      mixinImpl.maybeDistributeAttributeChange(this, name);\r\n    }\r\n  },\r\n\r\n  removeAttribute(name) {\r\n    nativeRemoveAttribute.call(this, name);\r\n    if (!mixinImpl.maybeDistributeParent(this)) {\r\n      mixinImpl.maybeDistributeAttributeChange(this, name);\r\n    }\r\n  }\r\n\r\n};\r\n\r\nObject.defineProperties(ElementMixin, {\r\n\r\n  shadowRoot: {\r\n    get() {\r\n      return this.shadyRoot;\r\n    }\r\n  },\r\n\r\n  slot: {\r\n    get() {\r\n      return this.getAttribute('slot');\r\n    },\r\n    set(value) {\r\n      this.setAttribute('slot', value);\r\n    }\r\n  }\r\n\r\n});\r\n\r\nlet activeElementDescriptor = {\r\n  get() {\r\n    return mixinImpl.activeElementForNode(this);\r\n  }\r\n}\r\n\r\nlet ActiveElementMixin = {};\r\nObject.defineProperties(ActiveElementMixin, {\r\n  activeElement: activeElementDescriptor\r\n});\r\n\r\nlet UnderActiveElementMixin = {};\r\nObject.defineProperties(UnderActiveElementMixin, {\r\n  _activeElement: activeElementDescriptor\r\n});\r\n\r\nexport let Mixins = {\r\n\r\n  CharacterData: utils.extendAll({__patched: 'CharacterData'},\r\n    NodeMixin, ChildNodeMixin),\r\n\r\n  Fragment: utils.extendAll({__patched: 'Fragment'},\r\n    NodeMixin, ParentNodeMixin, FragmentMixin, ActiveElementMixin),\r\n\r\n  Element: utils.extendAll({__patched: 'Element'},\r\n    NodeMixin, ParentNodeMixin, ChildNodeMixin, FragmentMixin, ElementMixin, ActiveElementMixin),\r\n\r\n  // Note: activeElement cannot be patched on document!\r\n  Document: utils.extendAll({__patched: 'Document'},\r\n    NodeMixin, ParentNodeMixin, FragmentMixin, ElementMixin, UnderActiveElementMixin)\r\n\r\n};\r\n\r\nexport let getRootNode = function(node) {\r\n  return mixinImpl.getRootNode(node);\r\n}\r\n\r\nexport function filterMutations(mutations, target) {\r\n  const targetRootNode = getRootNode(target);\r\n  return mutations.filter(function(mutation) {\r\n    const mutationInScope = (targetRootNode === getRootNode(mutation.target));\r\n    if (mutationInScope && mutation.addedNodes) {\r\n      let nodes = Array.from(mutation.addedNodes).filter(function(n) {\r\n        return (targetRootNode === getRootNode(n));\r\n      });\r\n      Object.defineProperty(mutation, 'addedNodes', {\r\n        value: nodes,\r\n        configurable: true\r\n      });\r\n    }\r\n    return mutationInScope &&\r\n      (!mutation.addedNodes || mutation.addedNodes.length);\r\n  });\r\n}\r\n\r\n// const promise = Promise.resolve();\r\n\r\nclass AsyncObserver {\r\n\r\n  constructor() {\r\n    this._scheduled = false;\r\n    this.addedNodes = [];\r\n    this.removedNodes = [];\r\n    this.callbacks = new Set();\r\n  }\r\n\r\n  schedule() {\r\n    if (!this._scheduled) {\r\n      this._scheduled = true;\r\n      utils.promish.then(() => {\r\n        this.flush();\r\n      });\r\n    }\r\n  }\r\n\r\n  flush() {\r\n    if (this._scheduled) {\r\n      this._scheduled = false;\r\n      let mutations = this.takeRecords();\r\n      if (mutations.length) {\r\n        this.callbacks.forEach(function(cb) {\r\n          cb(mutations);\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  takeRecords() {\r\n    if (this.addedNodes.length || this.removedNodes.length) {\r\n      let mutations = [{\r\n        addedNodes: this.addedNodes,\r\n        removedNodes: this.removedNodes\r\n      }];\r\n      this.addedNodes = [];\r\n      this.removedNodes = [];\r\n      return mutations;\r\n    }\r\n    return [];\r\n  }\r\n\r\n}\r\n\r\n// TODO(sorvell): consider instead polyfilling MutationObserver\r\n// directly so that users do not have to fork their code.\r\n// Supporting the entire api may be challenging: e.g. filtering out\r\n// removed nodes in the wrong scope and seeing non-distributing\r\n// subtree child mutations.\r\nexport let observeChildren = function(node, callback) {\r\n  utils.common.patchNode(node);\r\n  if (!node.__dom.observer) {\r\n    node.__dom.observer = new AsyncObserver();\r\n  }\r\n  node.__dom.observer.callbacks.add(callback);\r\n  let observer = node.__dom.observer;\r\n  return {\r\n    _callback: callback,\r\n    _observer: observer,\r\n    _node: node,\r\n    takeRecords() {\r\n      return observer.takeRecords()\r\n    }\r\n  };\r\n}\r\n\r\nexport let unobserveChildren = function(handle) {\r\n  let observer = handle && handle._observer;\r\n  if (observer) {\r\n    observer.callbacks.delete(handle._callback);\r\n    if (!observer.callbacks.size) {\r\n      handle._node.__dom.observer = null;\r\n    }\r\n  }\r\n}\r\n\r\n// https://dom.spec.whatwg.org/#converting-nodes-into-a-node\r\nfunction convertNodesIntoANode(nodes, document) {\r\n  let node = null;\r\n\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    const item = nodes[i];\r\n\r\n    if (typeof item === \"string\") {\r\n      nodes[i] = document.createTextNode(item);\r\n    }\r\n    else if (!(item instanceof Node)) {\r\n      let error = new Error(`Cannot insert an item of type \"${typeof item}\"`);\r\n      error.name = 'TypeError';\r\n      throw error;\r\n    }\r\n    else {\r\n      let parent = tree.Logical.getParentNode(item);\r\n      mixinImpl.removeNodeFromParent(item, parent);\r\n    }\r\n  }\r\n\r\n  if (nodes.length === 1) {\r\n    node = nodes[0];\r\n  }\r\n  else {\r\n    node = document.createDocumentFragment();\r\n\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      node.appendChild(nodes[i]);\r\n    }\r\n  }\r\n\r\n  return node;\r\n}","/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n/**\r\n * Patches elements that interacts with ShadyDOM\r\n * such that tree traversal and mutation apis act like they would under\r\n * ShadowDOM.\r\n *\r\n * This import enables seemless interaction with ShadyDOM powered\r\n * custom elements, enabling better interoperation with 3rd party code,\r\n * libraries, and frameworks that use DOM tree manipulation apis.\r\n */\r\n\r\n'use strict';\r\nimport {tree} from './tree'\r\nimport * as utils from './utils'\r\nimport {Mixins} from './element-mixin'\r\n\r\nexport let patchedCount = 0;\r\n\r\nlet log = false;\r\n\r\nlet patchImpl = {\r\n\r\n  canPatchNode: function(node) {\r\n    switch (node) {\r\n      case document.head:\r\n      case document.documentElement:\r\n        return false;\r\n      default:\r\n        return true;\r\n    }\r\n  },\r\n\r\n  hasPrototypeDescriptors: Boolean(Object.getOwnPropertyDescriptor(\r\n    window.Node.prototype, 'textContent')),\r\n\r\n  patch: function(node) {\r\n    patchedCount++;\r\n    log && window.console.warn('patch node', node);\r\n    if (this.hasPrototypeDescriptors) {\r\n      utils.patchPrototype(node, this.mixinForObject(node));\r\n    } else {\r\n      window.console.warn('Patching instance rather than prototype', node);\r\n      utils.extend(node, this.mixinForNode(node));\r\n    }\r\n  },\r\n\r\n  mixinForObject: function(obj) {\r\n    switch (obj.nodeType) {\r\n      case Node.ELEMENT_NODE:\r\n        return Mixins.Element;\r\n      case Node.DOCUMENT_FRAGMENT_NODE:\r\n        return Mixins.Fragment;\r\n      case Node.DOCUMENT_NODE:\r\n        return Mixins.Document;\r\n      case Node.TEXT_NODE:\r\n      case Node.COMMENT_NODE:\r\n        return Mixins.CharacterData;\r\n    }\r\n  },\r\n\r\n  unpatch: function(obj) {\r\n    if (obj.__sourceProto) {\r\n      obj.__proto__ = obj.__sourceProto;\r\n\r\n    }\r\n    // TODO(sorvell): implement unpatching for non-proto patchable browsers\r\n  }\r\n\r\n};\r\n\r\nexport function patchNode(node) {\r\n  if (!utils.settings.inUse) {\r\n    return;\r\n  }\r\n  if (!isNodePatched(node) && patchImpl.canPatchNode(node)) {\r\n    tree.saveChildNodes(node);\r\n    patchImpl.patch(node);\r\n  }\r\n}\r\n\r\nexport function unpatchNode(node) {\r\n  patchImpl.unpatch(node);\r\n}\r\n\r\nexport function isNodePatched(node) {\r\n  return Boolean(node.__patched);\r\n}\r\n\r\n// TODO(sorvell): fake export\r\nutils.common.patchNode = patchNode;\r\nutils.common.isNodePatched = isNodePatched;","/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n'use strict';\r\n\r\nimport * as utils from './utils'\r\n\r\nlet origAddEventListener = Element.prototype.addEventListener;\r\nlet origRemoveEventListener = Element.prototype.removeEventListener;\r\n\r\n// https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\r\nlet alwaysComposed = {\r\n  blur: true,\r\n  focus: true,\r\n  focusin: true,\r\n  focusout: true,\r\n  click: true,\r\n  dblclick: true,\r\n  mousedown: true,\r\n  mouseenter: true,\r\n  mouseleave: true,\r\n  mousemove: true,\r\n  mouseout: true,\r\n  mouseover: true,\r\n  mouseup: true,\r\n  wheel: true,\r\n  beforeinput: true,\r\n  input: true,\r\n  keydown: true,\r\n  keyup: true,\r\n  compositionstart: true,\r\n  compositionupdate: true,\r\n  compositionend: true,\r\n  touchstart: true,\r\n  touchend: true,\r\n  touchmove: true,\r\n  touchcancel: true,\r\n  pointerover: true,\r\n  pointerenter: true,\r\n  pointerdown: true,\r\n  pointermove: true,\r\n  pointerup: true,\r\n  pointercancel: true,\r\n  pointerout: true,\r\n  pointerleave: true,\r\n  gotpointercapture: true,\r\n  lostpointercapture: true,\r\n  dragstart: true,\r\n  drag: true,\r\n  dragenter: true,\r\n  dragleave: true,\r\n  dragover: true,\r\n  drop: true,\r\n  dragend: true,\r\n  DOMActivate: true,\r\n  DOMFocusIn: true,\r\n  DOMFocusOut: true,\r\n  keypress: true\r\n};\r\n\r\nfunction pathComposer(startNode, composed) {\r\n  let composedPath = [];\r\n  let current = startNode;\r\n  let startRoot = startNode === window ? window : startNode.getRootNode();\r\n  while (current) {\r\n    composedPath.push(current);\r\n    if (current.assignedSlot) {\r\n      current = current.assignedSlot;\r\n    } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {\r\n      current = current.host;\r\n    } else {\r\n      current = current.parentNode;\r\n    }\r\n  }\r\n  // event composedPath includes window when startNode's ownerRoot is document\r\n  if (composedPath[composedPath.length - 1] === document) {\r\n    composedPath.push(window);\r\n  }\r\n  return composedPath;\r\n}\r\n\r\nfunction retarget(refNode, path) {\r\n  if (!utils.isShadyRoot) {\r\n    return refNode;\r\n  }\r\n  // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\r\n  // shadow-including inclusive ancestor, return ANCESTOR.\r\n  let refNodePath = pathComposer(refNode, true);\r\n  let p$ = path;\r\n  for (let i=0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\r\n    ancestor = p$[i];\r\n    root = ancestor === window ? window : ancestor.getRootNode();\r\n    if (root !== lastRoot) {\r\n      rootIdx = refNodePath.indexOf(root);\r\n      lastRoot = root;\r\n    }\r\n    if (!utils.isShadyRoot(root) || rootIdx > -1) {\r\n      return ancestor;\r\n    }\r\n  }\r\n}\r\n\r\nlet EventMixin = {\r\n\r\n  __patched: 'Event',\r\n\r\n  get composed() {\r\n    if (this.isTrusted && this.__composed === undefined) {\r\n      this.__composed = alwaysComposed[this.type];\r\n    }\r\n    return this.__composed || false;\r\n  },\r\n\r\n  composedPath() {\r\n    if (!this.__composedPath) {\r\n      this.__composedPath = pathComposer(this.__target, this.composed);\r\n    }\r\n    return this.__composedPath;\r\n  },\r\n\r\n  get target() {\r\n    return retarget(this.currentTarget, this.composedPath());\r\n  },\r\n\r\n  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting\r\n  get relatedTarget() {\r\n    if (!this.__relatedTarget) {\r\n      return null;\r\n    }\r\n    if (!this.__relatedTargetComposedPath) {\r\n      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);\r\n    }\r\n    // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget\r\n    return retarget(this.currentTarget, this.__relatedTargetComposedPath);\r\n  },\r\n  stopPropagation() {\r\n    Event.prototype.stopPropagation.call(this);\r\n    this.__propagationStopped = true;\r\n  },\r\n  stopImmediatePropagation() {\r\n    Event.prototype.stopImmediatePropagation.call(this);\r\n    this.__immediatePropagationStopped = true;\r\n    this.__propagationStopped = true;\r\n  }\r\n\r\n};\r\n\r\nfunction mixinComposedFlag(Base) {\r\n  // NOTE: avoiding use of `class` here so that transpiled output does not\r\n  // try to do `Base.call` with a dom construtor.\r\n  let klazz = function(type, options) {\r\n    let event = new Base(type, options);\r\n    event.__composed = options && Boolean(options.composed);\r\n    return event;\r\n  }\r\n  // put constructor properties on subclass\r\n  utils.mixin(klazz, Base);\r\n  klazz.prototype = Base.prototype;\r\n  return klazz;\r\n}\r\n\r\nlet nonBubblingEventsToRetarget = {\r\n  focus: true,\r\n  blur: true\r\n};\r\n\r\nfunction fireHandlers(event, node, phase) {\r\n  let hs = node.__handlers && node.__handlers[event.type] &&\r\n    node.__handlers[event.type][phase];\r\n  if (hs) {\r\n    for (let i = 0, fn; (fn = hs[i]); i++) {\r\n      fn.call(node, event);\r\n      if (event.__immediatePropagationStopped) {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction retargetNonBubblingEvent(e) {\r\n  let path = e.composedPath();\r\n  let node;\r\n  // override `currentTarget` to let patched `target` calculate correctly\r\n  Object.defineProperty(e, 'currentTarget', {\r\n    get: function() {\r\n      return node;\r\n    },\r\n    configurable: true\r\n  });\r\n  for (let i = path.length - 1; i >= 0; i--) {\r\n    node = path[i];\r\n    fireHandlers(e, node, 'capture');\r\n    if (e.__propagationStopped) {\r\n      return;\r\n    }\r\n  }\r\n  Object.defineProperty(e, 'eventPhase', {value: Event.BUBBLING_PHASE});\r\n  for (let i = 0; i < path.length; i++) {\r\n    node = path[i];\r\n    fireHandlers(e, node, 'bubble');\r\n    if (e.__propagationStopped) {\r\n      return;\r\n    }\r\n  }\r\n}\r\n\r\nfunction shouldCapture(optionsOrCapture) {\r\n  return Boolean(typeof optionsOrCapture === 'object' ?\r\n    optionsOrCapture.capture : optionsOrCapture);\r\n}\r\n\r\nexport function addEventListener(type, fn, optionsOrCapture) {\r\n  if (!fn) {\r\n    return;\r\n  }\r\n  // TODO: investigate if this is worth tracking, as it is only used for\r\n  // deciding if the `slotchanged` event should be fired\r\n  if (!this.__eventListenerCount) {\r\n    this.__eventListenerCount = 0;\r\n  }\r\n  this.__eventListenerCount++;\r\n  let wrappedFn = function(e) {\r\n    if (!e.__target) {\r\n      e.__target = e.target;\r\n      e.__relatedTarget = e.relatedTarget;\r\n      utils.patchPrototype(e, EventMixin);\r\n    }\r\n    // There are two critera that should stop events from firing on this node\r\n    // 1. the event is not composed and the current node is not in the same root as the target\r\n    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node\r\n    if (e.composed || e.composedPath().indexOf(this) > -1) {\r\n      if (e.eventPhase === Event.BUBBLING_PHASE) {\r\n        if (e.target === e.relatedTarget) {\r\n          e.stopImmediatePropagation();\r\n          return;\r\n        }\r\n      }\r\n      return fn(e);\r\n    }\r\n  };\r\n  fn.__eventWrapper = wrappedFn;\r\n  if (nonBubblingEventsToRetarget[type]) {\r\n    this.__handlers = this.__handlers || {};\r\n    this.__handlers[type] = this.__handlers[type] || {capture: [], bubble: []};\r\n    if (shouldCapture(optionsOrCapture)) {\r\n      this.__handlers[type].capture.push(wrappedFn);\r\n    } else {\r\n      this.__handlers[type].bubble.push(wrappedFn);\r\n    }\r\n  } else {\r\n    origAddEventListener.call(this, type, wrappedFn, optionsOrCapture);\r\n  }\r\n}\r\n\r\nexport function removeEventListener(type, fn, optionsOrCapture) {\r\n  if (!fn) {\r\n    return;\r\n  }\r\n  let wrapper = fn.__eventWrapper;\r\n  origRemoveEventListener.call(this, type, wrapper || fn, optionsOrCapture);\r\n  if (wrapper) {\r\n    fn.__eventWrapper = null;\r\n    this.__eventListenerCount--;\r\n    if (nonBubblingEventsToRetarget[type]) {\r\n      if (this.__handlers) {\r\n        if (this.__handlers[type]) {\r\n          let idx;\r\n          if (shouldCapture(optionsOrCapture)) {\r\n            idx = this.__handlers[type].capture.indexOf(wrapper);\r\n            if (idx > -1) {\r\n              this.__handlers[type].capture.splice(idx, 1);\r\n            }\r\n          } else {\r\n            idx = this.__handlers[type].bubble.indexOf(wrapper);\r\n            if (idx > -1) {\r\n              this.__handlers[type].bubble.splice(idx, 1);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function activateFocusEventOverrides() {\r\n  for (let ev in nonBubblingEventsToRetarget) {\r\n    window.addEventListener(ev, function(e) {\r\n      if (!e.__target) {\r\n        e.__target = e.target;\r\n        e.__relatedTarget = e.relatedTarget;\r\n        utils.patchPrototype(e, EventMixin);\r\n        retargetNonBubblingEvent(e);\r\n        e.stopImmediatePropagation();\r\n      }\r\n    }, true);\r\n  }\r\n}\r\n\r\nexport let OriginalEvent = Event;\r\nexport let PatchedEvent = mixinComposedFlag(Event);\r\nexport let PatchedCustomEvent = mixinComposedFlag(CustomEvent);\r\nexport let PatchedMouseEvent = mixinComposedFlag(MouseEvent);\r\n","/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n'use strict';\r\n\r\nimport {tree} from './tree'\r\n\r\n// NOTE: normalize event contruction where necessary (IE11)\r\nlet NormalizedEvent = typeof Event === 'function' ? Event :\r\n  function(inType, params) {\r\n    params = params || {};\r\n    var e = document.createEvent('Event');\r\n    e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));\r\n    return e;\r\n  };\r\n\r\nexport default class {\r\n\r\n  constructor(root) {\r\n    this.root = root;\r\n    this.insertionPointTag = 'slot';\r\n  }\r\n\r\n  getInsertionPoints() {\r\n    return this.root.querySelectorAll(this.insertionPointTag);\r\n  }\r\n\r\n  hasInsertionPoint() {\r\n    return Boolean(this.root._insertionPoints &&\r\n      this.root._insertionPoints.length);\r\n  }\r\n\r\n  isInsertionPoint(node) {\r\n    return node.localName && node.localName == this.insertionPointTag;\r\n  }\r\n\r\n  distribute() {\r\n    if (this.hasInsertionPoint()) {\r\n      return this.distributePool(this.root, this.collectPool());\r\n    }\r\n    return [];\r\n  }\r\n\r\n  // Gather the pool of nodes that should be distributed. We will combine\r\n  // these with the \"content root\" to arrive at the composed tree.\r\n  collectPool() {\r\n    return tree.arrayCopy(\r\n      tree.Logical.getChildNodes(this.root.host));\r\n  }\r\n\r\n  // perform \"logical\" distribution; note, no actual dom is moved here,\r\n  // instead elements are distributed into storage\r\n  // array where applicable.\r\n  distributePool(node, pool) {\r\n    let dirtyRoots = [];\r\n    let p$ = this.root._insertionPoints;\r\n    for (let i=0, l=p$.length, p; (i<l) && (p=p$[i]); i++) {\r\n      this.distributeInsertionPoint(p, pool);\r\n      // provoke redistribution on insertion point parents\r\n      // must do this on all candidate hosts since distribution in this\r\n      // scope invalidates their distribution.\r\n      // only get logical parent.\r\n      let parent = tree.Logical.getParentNode(p);\r\n      if (parent && parent.shadyRoot &&\r\n          this.hasInsertionPoint(parent.shadyRoot)) {\r\n        dirtyRoots.push(parent.shadyRoot);\r\n      }\r\n    }\r\n    for (let i=0; i < pool.length; i++) {\r\n      let p = pool[i];\r\n      if (p) {\r\n        p._assignedSlot = undefined;\r\n        // remove undistributed elements from physical dom.\r\n        let parent = tree.Composed.getParentNode(p);\r\n        if (parent) {\r\n          tree.Composed.removeChild(parent, p);\r\n        }\r\n      }\r\n    }\r\n    return dirtyRoots;\r\n  }\r\n\r\n  distributeInsertionPoint(insertionPoint, pool) {\r\n    let prevAssignedNodes = insertionPoint._assignedNodes;\r\n    if (prevAssignedNodes) {\r\n      this.clearAssignedSlots(insertionPoint, true);\r\n    }\r\n    insertionPoint._assignedNodes = [];\r\n    let needsSlotChange = false;\r\n    // distribute nodes from the pool that this selector matches\r\n    let anyDistributed = false;\r\n    for (let i=0, l=pool.length, node; i < l; i++) {\r\n      node=pool[i];\r\n      // skip nodes that were already used\r\n      if (!node) {\r\n        continue;\r\n      }\r\n      // distribute this node if it matches\r\n      if (this.matchesInsertionPoint(node, insertionPoint)) {\r\n        if (node.__prevAssignedSlot != insertionPoint) {\r\n          needsSlotChange = true;\r\n        }\r\n        this.distributeNodeInto(node, insertionPoint)\r\n        // remove this node from the pool\r\n        pool[i] = undefined;\r\n        // since at least one node matched, we won't need fallback content\r\n        anyDistributed = true;\r\n      }\r\n    }\r\n    // Fallback content if nothing was distributed here\r\n    if (!anyDistributed) {\r\n      let children = tree.Logical.getChildNodes(insertionPoint);\r\n      for (let j = 0, node; j < children.length; j++) {\r\n        node = children[j];\r\n        if (node.__prevAssignedSlot != insertionPoint) {\r\n          needsSlotChange = true;\r\n        }\r\n        this.distributeNodeInto(node, insertionPoint);\r\n      }\r\n    }\r\n    // we're already dirty if a node was newly added to the slot\r\n    // and we're also dirty if the assigned count decreased.\r\n    if (prevAssignedNodes) {\r\n      // TODO(sorvell): the tracking of previously assigned slots\r\n      // could instead by done with a Set and then we could\r\n      // avoid needing to iterate here to clear the info.\r\n      for (let i=0; i < prevAssignedNodes.length; i++) {\r\n        prevAssignedNodes[i].__prevAssignedSlot = null;\r\n      }\r\n      if (insertionPoint._assignedNodes.length < prevAssignedNodes.length) {\r\n        needsSlotChange = true;\r\n      }\r\n    }\r\n    this.setDistributedNodesOnInsertionPoint(insertionPoint);\r\n    if (needsSlotChange) {\r\n      this._fireSlotChange(insertionPoint);\r\n    }\r\n  }\r\n\r\n  clearAssignedSlots(slot, savePrevious) {\r\n    let n$ = slot._assignedNodes;\r\n    if (n$) {\r\n      for (let i=0; i < n$.length; i++) {\r\n        let n = n$[i];\r\n        if (savePrevious) {\r\n          n.__prevAssignedSlot = n._assignedSlot;\r\n        }\r\n        // only clear if it was previously set to this slot;\r\n        // this helps ensure that if the node has otherwise been distributed\r\n        // ignore it.\r\n        if (n._assignedSlot === slot) {\r\n          n._assignedSlot = null;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  matchesInsertionPoint(node, insertionPoint) {\r\n    let slotName = insertionPoint.getAttribute('name');\r\n    slotName = slotName ? slotName.trim() : '';\r\n    let slot = node.getAttribute && node.getAttribute('slot');\r\n    slot = slot ? slot.trim() : '';\r\n    return (slot == slotName);\r\n  }\r\n\r\n  distributeNodeInto(child, insertionPoint) {\r\n    insertionPoint._assignedNodes.push(child);\r\n    child._assignedSlot = insertionPoint;\r\n  }\r\n\r\n  setDistributedNodesOnInsertionPoint(insertionPoint) {\r\n    let n$ = insertionPoint._assignedNodes;\r\n    insertionPoint._distributedNodes = [];\r\n    for (let i=0, n; (i<n$.length) && (n=n$[i]) ; i++) {\r\n      if (this.isInsertionPoint(n)) {\r\n        let d$ = n._distributedNodes;\r\n        if (d$) {\r\n          for (let j=0; j < d$.length; j++) {\r\n            insertionPoint._distributedNodes.push(d$[j]);\r\n          }\r\n        }\r\n      } else {\r\n        insertionPoint._distributedNodes.push(n$[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  _fireSlotChange(insertionPoint) {\r\n    // NOTE: cannot bubble correctly here so not setting bubbles: true\r\n    // Safari tech preview does not bubble but chrome does\r\n    // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)\r\n    insertionPoint.dispatchEvent(new NormalizedEvent('slotchange'));\r\n    if (insertionPoint._assignedSlot) {\r\n      this._fireSlotChange(insertionPoint._assignedSlot);\r\n    }\r\n  }\r\n\r\n  isFinalDestination(insertionPoint) {\r\n    return !(insertionPoint._assignedSlot);\r\n  }\r\n\r\n}","/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n/**\r\n * Patches elements that interacts with ShadyDOM\r\n * such that tree traversal and mutation apis act like they would under\r\n * ShadowDOM.\r\n *\r\n * This import enables seemless interaction with ShadyDOM powered\r\n * custom elements, enabling better interoperation with 3rd party code,\r\n * libraries, and frameworks that use DOM tree manipulation apis.\r\n */\r\n\r\n'use strict';\r\nimport * as utils from './utils'\r\nimport {ShadyRoot, flush, enqueue} from './shady'\r\nimport * as patch from './patch'\r\nimport {getRootNode, filterMutations, observeChildren, unobserveChildren}\r\n  from './element-mixin'\r\nimport * as events from './event-mixin'\r\nimport {tree, getNativeProperty} from './tree'\r\n\r\nif (utils.settings.inUse) {\r\n\r\n  window.ShadyDOM = {\r\n    tree: tree,\r\n    getNativeProperty: getNativeProperty,\r\n    patch: patch.patchNode,\r\n    isPatched: patch.isNodePatched,\r\n    unpatch: patch.unpatchNode,\r\n    isShadyRoot: utils.isShadyRoot,\r\n    enqueue: enqueue,\r\n    flush: flush,\r\n    inUse: utils.settings.inUse,\r\n    filterMutations: filterMutations,\r\n    observeChildren: observeChildren,\r\n    unobserveChildren: unobserveChildren\r\n  };\r\n\r\n  let createRootAndEnsurePatched = function(node) {\r\n    // TODO(sorvell): need to ensure ancestors are patched but this introduces\r\n    // a timing problem with gathering composed children.\r\n    // (1) currently the child list is crawled and patched when patching occurs\r\n    // (this needs to change)\r\n    // (2) we can only patch when an element has received its parsed children\r\n    // because we cannot detect them when inserted by parser.\r\n    // let ancestor = node;\r\n    // while (ancestor) {\r\n    //   patchNode(ancestor);\r\n    //   ancestor = ancestor.parentNode || ancestor.host;\r\n    // }\r\n    patch.patchNode(node);\r\n    let root = new ShadyRoot(node);\r\n    patch.patchNode(root);\r\n    return root;\r\n  }\r\n\r\n  Element.prototype.attachShadow = function() {\r\n    return createRootAndEnsurePatched(this);\r\n  }\r\n\r\n  Node.prototype.addEventListener = events.addEventListener;\r\n  Node.prototype.removeEventListener = events.removeEventListener;\r\n  Event = events.PatchedEvent;\r\n  CustomEvent = events.PatchedCustomEvent;\r\n  MouseEvent = events.PatchedMouseEvent;\r\n  events.activateFocusEventOverrides();\r\n\r\n  Object.defineProperty(Node.prototype, 'isConnected', {\r\n    get() {\r\n      return document.documentElement.contains(this);\r\n    },\r\n    configurable: true\r\n  });\r\n\r\n  Node.prototype.getRootNode = function(options) {\r\n    return getRootNode(this, options);\r\n  }\r\n\r\n  Object.defineProperty(Element.prototype, 'slot', {\r\n    get() {\r\n      return this.getAttribute('slot');\r\n    },\r\n    set(value) {\r\n      this.setAttribute('slot', value);\r\n    },\r\n    configurable: true\r\n  });\r\n\r\n  Object.defineProperty(Node.prototype, 'assignedSlot', {\r\n    get() {\r\n      return this._assignedSlot || null;\r\n    },\r\n    configurable: true\r\n  });\r\n\r\n  // TODO(sorvell): super experimental auto patching of document fragment\r\n  // via appendChild. This either needs to be expanded or contracted.\r\n  // DocumentFragment.prototype.appendChild = function(node) {\r\n  //   patchNode(this);\r\n  //   return this.appendChild(node);\r\n  // }\r\n\r\n}\r\n"]}